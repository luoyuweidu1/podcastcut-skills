<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>__TITLE__</title>
<style>
:root {
  --blue: #2563eb;
  --green: #16a34a;
  --purple: #9333ea;
  --red-bg: #fef2f2;
  --red-border: #fecaca;
  --orange: #ea580c;
  --gray-50: #f9fafb;
  --gray-100: #f3f4f6;
  --gray-200: #e5e7eb;
  --gray-300: #d1d5db;
  --gray-400: #9ca3af;
  --gray-500: #6b7280;
  --gray-600: #4b5563;
  --gray-700: #374151;
  --gray-800: #1f2937;
  --gray-900: #111827;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif;
  background: var(--gray-50);
  color: var(--gray-800);
  line-height: 1.6;
}

/* Fixed top audio bar */
.audio-bar {
  position: fixed;
  top: 0; left: 0; right: 0;
  z-index: 1000;
  background: white;
  border-bottom: 1px solid var(--gray-200);
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  padding: 8px 16px;
}

.audio-bar-inner {
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  gap: 16px;
  align-items: center;
}

.audio-player {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 0;
}

.audio-player .label {
  font-size: 12px;
  font-weight: 600;
  color: var(--gray-600);
  white-space: nowrap;
  min-width: 50px;
}

.audio-player .play-btn {
  width: 32px; height: 32px;
  border-radius: 50%;
  border: none;
  background: var(--blue);
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-size: 14px;
}

.audio-player .play-btn:hover { background: #1d4ed8; }
.audio-player .play-btn.playing { background: #dc2626; }

.progress-container {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 6px;
  min-width: 0;
}

.progress-bar {
  flex: 1;
  height: 6px;
  background: var(--gray-200);
  border-radius: 3px;
  cursor: pointer;
  position: relative;
  min-width: 80px;
}

.progress-fill {
  height: 100%;
  background: var(--blue);
  border-radius: 3px;
  width: 0%;
  transition: width 0.1s;
}

.time-display {
  font-size: 11px;
  color: var(--gray-500);
  white-space: nowrap;
  font-variant-numeric: tabular-nums;
  min-width: 80px;
}

.speed-btn {
  font-size: 11px;
  padding: 2px 6px;
  border: 1px solid var(--gray-300);
  border-radius: 4px;
  background: white;
  cursor: pointer;
  color: var(--gray-600);
  white-space: nowrap;
}

.speed-btn:hover { background: var(--gray-100); }

.export-btn {
  font-size: 12px;
  padding: 6px 14px;
  border: none;
  border-radius: 6px;
  background: #059669;
  color: white;
  cursor: pointer;
  font-weight: 600;
  white-space: nowrap;
  transition: background 0.15s;
}

.export-btn:hover { background: #047857; }

/* Missed Catch styles */
.missed-catch {
  text-decoration: underline dashed;
  text-decoration-color: #2563eb;
  background: #eff6ff;
  color: #1e40af;
  padding: 0 2px;
  border-radius: 2px;
  cursor: pointer;
  transition: all 0.15s;
}
.missed-catch:hover {
  background: #dbeafe;
  outline: 1px dashed #2563eb;
}
.missed-catch-tag {
  display: inline-block;
  padding: 1px 5px;
  border-radius: 3px;
  font-size: 9px;
  font-weight: 600;
  background: #eff6ff;
  color: #2563eb;
  border: 1px solid #bfdbfe;
  margin-right: 4px;
  cursor: pointer;
  user-select: none;
}
#missed-catch-panel {
  display: none;
  position: fixed;
  z-index: 1001;
  background: white;
  border: 1px solid var(--gray-300);
  border-radius: 10px;
  padding: 14px 16px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.18);
  font-size: 13px;
  width: 320px;
}
#missed-catch-panel.visible { display: block; }
#missed-catch-panel .mc-title {
  font-weight: 700;
  font-size: 14px;
  margin-bottom: 10px;
  color: var(--gray-800);
}
#missed-catch-panel .mc-preview {
  background: #eff6ff;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 12px;
  color: #1e40af;
  margin-bottom: 10px;
  max-height: 60px;
  overflow: hidden;
  word-break: break-all;
}
#missed-catch-panel select {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid var(--gray-300);
  border-radius: 6px;
  font-size: 13px;
  margin-bottom: 8px;
}
#missed-catch-panel input[type="text"] {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid var(--gray-300);
  border-radius: 6px;
  font-size: 13px;
  margin-bottom: 10px;
}
#missed-catch-panel .mc-btns {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
#missed-catch-panel .mc-btn {
  padding: 5px 14px;
  border-radius: 6px;
  border: none;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
}
#missed-catch-panel .mc-btn-ok {
  background: #2563eb;
  color: white;
}
#missed-catch-panel .mc-btn-ok:hover { background: #1d4ed8; }
#missed-catch-panel .mc-btn-cancel {
  background: var(--gray-100);
  color: var(--gray-600);
}
#missed-catch-panel .mc-btn-cancel:hover { background: var(--gray-200); }

/* Stats header */
.stats-header {
  margin-top: 56px;
  background: white;
  border-bottom: 1px solid var(--gray-200);
  padding: 16px 24px;
}

.stats-inner {
  max-width: 1400px;
  margin: 0 auto;
}

.stats-title {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 12px;
  color: var(--gray-900);
}

.stats-grid {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.stat-card {
  background: var(--gray-50);
  border: 1px solid var(--gray-200);
  border-radius: 8px;
  padding: 8px 14px;
  min-width: 100px;
}

.stat-value {
  font-size: 20px;
  font-weight: 700;
  color: var(--gray-900);
}

.stat-label {
  font-size: 11px;
  color: var(--gray-500);
}

.stat-card.dynamic {
  border-color: #059669;
  background: #f0fdf4;
}

.stat-card.dynamic .stat-value {
  color: #059669;
}

/* Summary Panel */
.summary-panel {
  background: white;
  border-bottom: 1px solid var(--gray-200);
}
.summary-panel-inner {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 24px;
}
.summary-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 0;
  cursor: pointer;
  user-select: none;
}
.summary-toggle:hover { opacity: 0.8; }
.summary-toggle h3 {
  font-size: 15px;
  font-weight: 700;
  color: var(--gray-800);
  margin: 0;
}
.summary-arrow {
  font-size: 12px;
  color: var(--gray-400);
  transition: transform 0.2s;
}
.summary-arrow.collapsed { transform: rotate(-90deg); }
.summary-body { padding-bottom: 16px; overflow-x: auto; }
.summary-body.collapsed { display: none; }
.summary-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}
.summary-table th {
  background: var(--gray-50);
  text-align: left;
  padding: 8px 10px;
  font-weight: 600;
  color: var(--gray-600);
  border-bottom: 2px solid var(--gray-200);
  white-space: nowrap;
}
.summary-table td {
  padding: 8px 10px;
  border-bottom: 1px solid var(--gray-100);
  vertical-align: middle;
}
.summary-table tbody tr:hover td { background: #fefce8; }
.summary-table tbody tr.block-unchecked td { opacity: 0.45; }
.summary-table tbody tr.block-unchecked .st-topic,
.summary-table tbody tr.block-unchecked .st-reason { text-decoration: line-through; }
.summary-table .st-check { width: 30px; text-align: center; }
.summary-table .st-id { width: 30px; color: var(--gray-400); font-size: 12px; }
.summary-table .st-topic { font-weight: 600; white-space: nowrap; }
.summary-table .st-type { width: 80px; }
.summary-table .st-pos {
  width: 80px;
  font-variant-numeric: tabular-nums;
  color: var(--gray-500);
  cursor: pointer;
  font-size: 12px;
}
.summary-table .st-pos:hover { color: var(--blue); text-decoration: underline; }
.summary-table .st-dur {
  width: 55px;
  font-variant-numeric: tabular-nums;
  font-weight: 600;
  text-align: right;
}
.summary-table .st-reason { color: var(--gray-600); font-size: 12px; max-width: 400px; }
.summary-type-tag {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 3px;
  font-size: 11px;
  color: white;
  font-weight: 500;
  white-space: nowrap;
}
.summary-footer {
  display: flex;
  gap: 32px;
  padding: 14px 10px 4px;
  border-top: 2px solid var(--gray-200);
  margin-top: 4px;
  flex-wrap: wrap;
}
.sf-item { display: flex; align-items: baseline; gap: 6px; }
.sf-label { color: var(--gray-500); font-size: 13px; }
.sf-value { font-weight: 700; font-size: 18px; font-variant-numeric: tabular-nums; }
.sf-value.cut { color: #dc2626; }
.sf-value.result { color: #059669; }

/* Filter controls */
.filter-bar {
  background: white;
  border-bottom: 1px solid var(--gray-200);
  padding: 10px 24px;
  position: sticky;
  top: 56px;
  z-index: 999;
}

.filter-inner {
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

.filter-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--gray-500);
  margin-right: 4px;
}

.filter-btn {
  font-size: 12px;
  padding: 4px 10px;
  border: 1px solid var(--gray-300);
  border-radius: 16px;
  background: white;
  cursor: pointer;
  color: var(--gray-600);
  transition: all 0.15s;
}

.filter-btn:hover { border-color: var(--gray-400); background: var(--gray-50); }
.filter-btn.active { background: var(--blue); color: white; border-color: var(--blue); }
.filter-btn.active-red { background: #dc2626; color: white; border-color: #dc2626; }
.info-tip {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 15px; height: 15px;
  border-radius: 50%;
  border: 1px solid #cbd5e1;
  color: #94a3b8;
  font-size: 10px;
  font-style: italic;
  font-family: serif;
  cursor: help;
  flex-shrink: 0;
}
.info-tip .info-text {
  display: none;
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 6px;
  background: #1e293b;
  color: #e2e8f0;
  font-size: 12px;
  font-style: normal;
  font-family: inherit;
  padding: 8px 12px;
  border-radius: 6px;
  white-space: nowrap;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 9999;
}
.info-tip:hover .info-text { display: block; }

.filter-separator {
  width: 1px; height: 20px;
  background: var(--gray-300);
  margin: 0 4px;
}

/* Transcript container */
.transcript {
  max-width: 1400px;
  margin: 0 auto;
  padding: 16px 24px;
  padding-bottom: 120px;
}

/* Sentence row */
.sentence-row {
  display: flex;
  align-items: flex-start;
  padding: 6px 8px;
  border-radius: 6px;
  margin-bottom: 2px;
  transition: background 0.15s, border-color 0.15s;
  cursor: pointer;
  border: 2px solid transparent;
}

.sentence-row:hover { background: var(--gray-100); }
.sentence-row.highlight { background: #fef9c3 !important; }
.sentence-row.deleted { background: #fef2f2; }
.sentence-row.deleted:hover { background: #fee2e2; }
.sentence-row.suggested-delete { background: #fffbeb; border: 2px dashed #fbbf24 !important; }
.sentence-row.suggested-delete:hover { background: #fef3c7; }
.sentence-row.hidden { display: none; }

/* User-modified highlight */
.sentence-row.user-modified {
  border-color: var(--blue) !important;
}

/* Selection popup (appears after mouse-drag selecting rows) */
.selection-popup {
  position: fixed;
  z-index: 1001;
  background: #1e293b;
  color: white;
  padding: 8px 12px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.25);
  font-size: 13px;
  pointer-events: auto;
  white-space: nowrap;
}
.selection-popup .sel-count { font-weight: 600; }
.selection-popup button {
  padding: 5px 12px;
  border: none;
  border-radius: 5px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
}
.selection-popup .sel-delete { background: #dc2626; color: white; }
.selection-popup .sel-delete:hover { background: #b91c1c; }
.selection-popup .sel-restore { background: #16a34a; color: white; }
.selection-popup .sel-restore:hover { background: #15803d; }

/* Checkbox column */
.s-check {
  display: none;
}

/* Block summary bar */
.block-bar {
  background: #fef2f2;
  border: 1px solid #fecaca;
  border-radius: 8px;
  padding: 8px 12px;
  margin: 8px 0 4px 0;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
}

.block-bar.hidden { display: none; }
.block-bar.suggested-block { background: #fffbeb; border-color: #fbbf24; border-style: dashed; }
.block-bar-icon { font-size: 16px; }
.block-bar-id { font-weight: 700; color: #dc2626; }
.suggested-block .block-bar-id { color: #d97706; }

.block-bar-type {
  display: inline-block;
  padding: 1px 8px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  color: white;
}

.block-bar-reason { color: var(--gray-600); flex: 1; }
.block-bar-duration { color: var(--gray-400); font-size: 12px; white-space: nowrap; }

/* Sentence parts */
.s-idx {
  width: 40px;
  flex-shrink: 0;
  font-size: 11px;
  color: var(--gray-400);
  text-align: right;
  padding-right: 8px;
  padding-top: 2px;
  font-variant-numeric: tabular-nums;
}

.s-speaker {
  width: 56px;
  flex-shrink: 0;
  font-size: 12px;
  font-weight: 600;
  padding-top: 2px;
  white-space: nowrap;
  cursor: pointer;
  border-radius: 3px;
  transition: background 0.15s;
}
.s-speaker:hover {
  background: rgba(255,255,255,0.15);
}
.speaker-edit-dropdown {
  position: absolute;
  z-index: 1000;
  background: #1e293b;
  border: 1px solid #475569;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  padding: 4px 0;
  min-width: 120px;
}
.speaker-edit-dropdown div {
  padding: 6px 12px;
  cursor: pointer;
  font-size: 12px;
  color: #e2e8f0;
}
.speaker-edit-dropdown div:hover {
  background: #334155;
}
.speaker-edit-dropdown input {
  margin: 4px 8px;
  padding: 4px 8px;
  font-size: 12px;
  background: #0f172a;
  border: 1px solid #475569;
  border-radius: 4px;
  color: #e2e8f0;
  width: calc(100% - 16px);
  box-sizing: border-box;
}

__SPEAKER_STYLES__

.s-time {
  width: 65px;
  flex-shrink: 0;
  font-size: 11px;
  color: var(--gray-400);
  padding-top: 2px;
  font-variant-numeric: tabular-nums;
  cursor: pointer;
}

.s-time:hover { color: var(--blue); text-decoration: underline; }

.s-text {
  flex: 1;
  font-size: 14px;
  line-height: 1.7;
  min-width: 0;
}

.s-text.deleted-text {
  text-decoration: line-through;
  color: #dc2626;
  opacity: 0.7;
}

.s-badges {
  display: flex;
  align-items: center;
  gap: 4px;
  flex-shrink: 0;
  padding-top: 2px;
}

/* Tags */
.tag {
  display: inline-block;
  padding: 0 6px;
  border-radius: 3px;
  font-size: 10px;
  font-weight: 600;
  color: white;
  margin-left: 4px;
  vertical-align: middle;
  line-height: 18px;
}

.ai-badge {
  display: inline-block;
  padding: 0 5px;
  border-radius: 3px;
  font-size: 9px;
  font-weight: 700;
  background: #ef4444;
  color: white;
  vertical-align: middle;
  line-height: 16px;
  letter-spacing: 0.5px;
}

.fine-tag {
  display: inline-block;
  padding: 1px 7px;
  border-radius: 3px;
  font-size: 10px;
  font-weight: 600;
  background: #fff7ed;
  color: var(--orange);
  border: 1px solid #fed7aa;
  margin-right: 6px;
  vertical-align: middle;
  line-height: 18px;
  cursor: pointer;
  user-select: none;
  transition: all 0.15s;
}

.fine-tag:hover { background: #fed7aa; }

.fine-tag.disabled {
  background: var(--gray-100);
  color: var(--gray-400);
  border-color: var(--gray-300);
  text-decoration: line-through;
}

.silence-pause {
  display: inline;
  font-size: 12px;
  color: var(--orange);
  letter-spacing: 0.5px;
  cursor: pointer;
  text-decoration: line-through;
  text-decoration-color: #dc2626;
  text-decoration-thickness: 2px;
  transition: all 0.15s;
}
.silence-pause:hover {
  color: var(--orange);
}
.silence-pause.disabled {
  text-decoration: none;
  color: #d1d5db;
}

.incoming-silence {
  display: inline-block;
  font-size: 11px;
  color: #b45309;
  background: #fef3c7;
  border: 1px dashed #f59e0b;
  border-radius: 3px;
  padding: 0 4px;
  margin-right: 4px;
  cursor: pointer;
  line-height: 1.4;
  vertical-align: baseline;
  transition: all 0.15s;
}
.incoming-silence:hover {
  background: #fde68a;
  color: #92400e;
}
.incoming-silence.disabled {
  background: #f3f4f6;
  border-color: #d1d5db;
  color: #9ca3af;
}

.silence-bar {
  display: inline;
  color: var(--orange);
  text-decoration: line-through;
  text-decoration-color: var(--orange);
  background: #fff7ed;
  padding: 0 3px;
  border-radius: 2px;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.15s;
  opacity: 0.85;
}
.silence-bar:hover { opacity: 1; background: #fed7aa; }
.silence-bar.disabled {
  color: var(--gray-400);
  text-decoration: none;
  background: var(--gray-100);
  opacity: 0.5;
}

.fine-delete {
  text-decoration: line-through;
  background: #fff7ed;
  color: var(--orange);
  padding: 0 2px;
  border-radius: 2px;
  cursor: pointer;
  transition: all 0.15s;
}

.fine-delete:hover {
  background: #fed7aa;
  outline: 1px dashed var(--orange);
}

.fine-delete.disabled {
  background: var(--gray-100);
  color: var(--gray-400);
  text-decoration: none;
  cursor: pointer;
}

.fine-delete.disabled:hover {
  background: #e5e7eb;
  outline: 1px dashed var(--gray-400);
}


/* Manual text selection deletion */
.manual-delete {
  text-decoration: line-through;
  background: #fef3c7;
  color: #d97706;
  padding: 0 2px;
  border-radius: 2px;
  cursor: pointer;
  transition: all 0.15s;
}

.manual-delete:hover {
  background: #fde68a;
  outline: 1px dashed #d97706;
}

.manual-delete.disabled {
  text-decoration: none;
  background: var(--gray-100);
  color: var(--gray-400);
}

.manual-tag {
  display: inline-block;
  padding: 1px 5px;
  border-radius: 3px;
  font-size: 9px;
  font-weight: 600;
  background: #fef3c7;
  color: #d97706;
  border: 1px solid #fde68a;
  margin-right: 4px;
  cursor: pointer;
  user-select: none;
  pointer-events: none;
}

.manual-tag.disabled {
  background: var(--gray-100);
  color: var(--gray-400);
  border-color: var(--gray-300);
  text-decoration: line-through;
}

#selection-toolbar {
  display: none;
  position: fixed;
  z-index: 1000;
  background: white;
  border: 1px solid var(--gray-300);
  border-radius: 8px;
  padding: 4px 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  font-size: 13px;
  gap: 6px;
  align-items: center;
}

#selection-toolbar.visible {
  display: flex;
}

#selection-toolbar button {
  padding: 4px 10px;
  border-radius: 4px;
  border: 1px solid #d97706;
  background: #fef3c7;
  color: #d97706;
  font-weight: 600;
  cursor: pointer;
  font-size: 12px;
}

#selection-toolbar button:hover {
  background: #fde68a;
}

#selection-toolbar button.comment-btn {
  border-color: #2563eb;
  background: #eff6ff;
  color: #2563eb;
}

#selection-toolbar button.comment-btn:hover {
  background: #dbeafe;
}

/* Comment annotation */
.comment-highlight {
  text-decoration: underline dashed #3b82f6;
  text-underline-offset: 3px;
  cursor: help;
  position: relative;
}

.comment-tag {
  font-size: 9px;
  color: #2563eb;
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  border-radius: 3px;
  padding: 0 3px;
  margin-left: 2px;
  pointer-events: none;
  vertical-align: super;
}

/* Comment/Restore panel (reuses missed-catch panel style) */
.feedback-panel {
  display: none;
  position: fixed;
  z-index: 1001;
  background: white;
  border: 1px solid var(--gray-300);
  border-radius: 10px;
  padding: 14px 16px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.18);
  font-size: 13px;
  width: 320px;
}
.feedback-panel.visible { display: block; }
.feedback-panel .mc-title { font-weight: 700; font-size: 14px; margin-bottom: 10px; color: var(--gray-800); }
.feedback-panel .mc-preview { background: #eff6ff; padding: 6px 10px; border-radius: 6px; font-size: 12px; color: #1e40af; margin-bottom: 10px; max-height: 60px; overflow: hidden; word-break: break-all; }
.feedback-panel select { width: 100%; padding: 6px 8px; border: 1px solid var(--gray-300); border-radius: 6px; font-size: 13px; margin-bottom: 8px; }
.feedback-panel input[type="text"] { width: 100%; padding: 6px 8px; border: 1px solid var(--gray-300); border-radius: 6px; font-size: 13px; margin-bottom: 10px; }
.feedback-panel .mc-btns { display: flex; gap: 8px; justify-content: flex-end; }
.feedback-panel .mc-btn { padding: 5px 14px; border-radius: 6px; border: none; font-size: 12px; font-weight: 600; cursor: pointer; }
.feedback-panel .mc-btn-ok { background: #2563eb; color: white; }
.feedback-panel .mc-btn-ok:hover { background: #1d4ed8; }
.feedback-panel .mc-btn-cancel { background: var(--gray-100); color: var(--gray-600); }
.feedback-panel .mc-btn-cancel:hover { background: var(--gray-200); }

#selection-toolbar .sel-text {
  color: var(--gray-500);
  font-size: 11px;
  max-width: 150px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Scroll to top */
.scroll-top {
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 40px; height: 40px;
  border-radius: 50%;
  background: var(--blue);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  font-size: 18px;
  display: none;
  z-index: 1001;
  align-items: center;
  justify-content: center;
}

.scroll-top.visible { display: flex; }

/* Search */
.search-input {
  font-size: 12px;
  padding: 4px 10px;
  border: 1px solid var(--gray-300);
  border-radius: 16px;
  width: 160px;
  outline: none;
}

.search-input:focus {
  border-color: var(--blue);
  box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
}

/* Undo toast */
.undo-toast {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--gray-800);
  color: white;
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 13px;
  z-index: 1002;
  display: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.undo-toast.visible { display: block; }

/* Keyboard shortcut hint */
.kbd {
  display: inline-block;
  background: var(--gray-100);
  border: 1px solid var(--gray-300);
  border-radius: 3px;
  padding: 0px 4px;
  font-size: 10px;
  font-family: monospace;
  color: var(--gray-600);
  margin-left: 4px;
}

/* Responsive */
@media (max-width: 768px) {
  .audio-bar-inner { flex-direction: column; gap: 8px; }
  .s-speaker { width: 44px; font-size: 11px; }
  .s-time { width: 50px; }
  .s-idx { width: 32px; }
  .s-check { display: none; }
}
</style>
</head>
<body>

<!-- Audio Bar -->
<div class="audio-bar">
  <div class="audio-bar-inner">
    <div class="audio-player" id="player-original">
      <span class="label">原始</span>
      <button class="play-btn" onclick="togglePlay('original')">&#9654;</button>
      <div class="progress-container">
        <div class="progress-bar" onclick="seekAudio(event, 'original')">
          <div class="progress-fill" id="progress-original"></div>
        </div>
        <span class="time-display" id="time-original">0:00 / 0:00</span>
      </div>
      <button class="speed-btn" onclick="cycleSpeed('original')">1x</button>
    </div>
    <div class="audio-player" id="player-cut">
      <span class="label">精剪(实时)</span>
      <button class="play-btn" onclick="togglePlay('cut')">&#9654;</button>
      <div class="progress-container">
        <div class="progress-bar" onclick="seekAudio(event, 'cut')">
          <div class="progress-fill" id="progress-cut"></div>
        </div>
        <span class="time-display" id="time-cut">0:00 / 0:00</span>
      </div>
      <button class="speed-btn" onclick="cycleSpeed('cut')">1x</button>
    </div>
    <div style="display:inline-flex;align-items:center;gap:4px;">
      <button class="export-btn" onclick="exportDeleteSegments()" style="background:#2d7d46;">&#9986; 导出剪辑文件</button>
      <span class="info-tip">i<span class="info-text">审查完成后点击导出，发给制作人即可剪辑</span></span>
    </div>
    <div style="display:inline-flex;align-items:center;gap:4px;">
      <label class="export-btn" style="background:#6b7280;cursor:pointer;margin:0;">&#128194; 导入编辑 <input type="file" accept=".json" onchange="importEditState(this)" style="display:none;"></label>
      <span class="info-tip">i<span class="info-text">收到别人的 JSON？导入即可查看对方的编辑</span></span>
    </div>
  </div>
</div>

<audio id="audio-original" src="__AUDIO_SRC__" preload="auto"></audio>
<!-- cut audio is now virtual - plays original with dynamic skipping -->

<!-- Stats Header -->
<div class="stats-header">
  <div class="stats-inner">
    <div class="stats-title">__TITLE__</div>
    <div class="stats-grid">
      <div class="stat-card"><div class="stat-value" id="stat-total">--</div><div class="stat-label">总句数</div></div>
      <div class="stat-card"><div class="stat-value" style="color:#dc2626" id="stat-ai-deleted">--</div><div class="stat-label">AI删除</div></div>
      <div class="stat-card"><div class="stat-value" style="color:#f59e0b" id="stat-ai-suggested">--</div><div class="stat-label">建议删除</div></div>
      <div class="stat-card"><div class="stat-value" style="color:#16a34a" id="stat-ai-kept">--</div><div class="stat-label">AI保留</div></div>
      <div class="stat-card"><div class="stat-value" style="color:var(--orange)" id="stat-fine-edits">--</div><div class="stat-label">精剪编辑</div></div>
      <div class="stat-card"><div class="stat-value" id="stat-blocks">--</div><div class="stat-label">删除段落</div></div>
      <div class="stat-card dynamic"><div class="stat-value" id="stat-user-add">+0</div><div class="stat-label">手动添加删除</div></div>
      <div class="stat-card dynamic"><div class="stat-value" id="stat-user-remove">-0</div><div class="stat-label">手动恢复</div></div>
      <div class="stat-card dynamic"><div class="stat-value" id="stat-final-delete">--</div><div class="stat-label">最终删除</div></div>
    </div>
  </div>
</div>

<!-- Summary Panel -->
<div class="summary-panel">
  <div class="summary-panel-inner">
    <div class="summary-toggle" onclick="toggleSummaryPanel()">
      <h3>内容删减概览</h3>
      <span class="summary-arrow" id="summary-arrow">&#9660;</span>
    </div>
    <div class="summary-body" id="summary-body">
      <table class="summary-table">
        <thead><tr>
          <th class="st-check"><input type="checkbox" id="summary-check-all" onchange="toggleAllBlocks(this.checked)" title="全选/全不选" checked></th>
          <th class="st-id">#</th>
          <th class="st-topic">话题</th>
          <th class="st-type">类型</th>
          <th class="st-pos">时间位置</th>
          <th class="st-dur">时长</th>
          <th class="st-reason">删减理由</th>
        </tr></thead>
        <tbody id="summary-tbody"></tbody>
      </table>
      <div class="summary-footer" id="summary-footer"></div>
    </div>
  </div>
</div>

<!-- Filter Bar -->
<div class="filter-bar">
  <div class="filter-inner">
    <span class="filter-label">显示:</span>
    <button class="filter-btn active" onclick="setFilter('all')">全部</button>
    <button class="filter-btn" onclick="setFilter('deleted')">仅删除</button>
    <button class="filter-btn" onclick="setFilter('kept')">仅保留</button>
    <div class="filter-separator"></div>
    <span class="filter-label">类型:</span>
    <button class="filter-btn active" data-type="all" onclick="setTypeFilter('all')">全部类型</button>
    <button class="filter-btn" data-type="pre_show" onclick="setTypeFilter('pre_show')">录前准备</button>
    <button class="filter-btn" data-type="tech_debug" onclick="setTypeFilter('tech_debug')">技术调试</button>
    <button class="filter-btn" data-type="chit_chat" onclick="setTypeFilter('chit_chat')">跑题闲聊</button>
    <button class="filter-btn" data-type="repeated_content" onclick="setTypeFilter('repeated_content')">重复内容</button>
    <button class="filter-btn" data-type="production_talk" onclick="setTypeFilter('production_talk')">制作讨论</button>
    <button class="filter-btn" data-type="privacy" onclick="setTypeFilter('privacy')">隐私保护</button>
    <span style="font-size:11px;color:var(--gray-400);margin:0 4px">|</span>
    <button class="filter-btn" data-type="redundant_viewpoint" onclick="setTypeFilter('redundant_viewpoint')">重复观点</button>
    <button class="filter-btn" data-type="over_detail" onclick="setTypeFilter('over_detail')">过度展开</button>
    <button class="filter-btn" data-type="low_density" onclick="setTypeFilter('low_density')">低密度</button>
    <button class="filter-btn" data-type="weak_relevance" onclick="setTypeFilter('weak_relevance')">弱相关</button>
    <div class="filter-separator"></div>
    <input class="search-input" type="text" placeholder="搜索文本..." oninput="searchText(this.value)">
    <span style="font-size:11px;color:var(--gray-400)">快捷键: <span class="kbd">D</span> 切换删除 <span class="kbd">Ctrl+Z</span> 撤销 | 鼠标拖选多句可批量操作</span>
    <div style="display:inline-flex;align-items:center;gap:4px;margin-left:8px;">
      <button class="export-btn" onclick="exportFeedback()" style="background:#2563eb;font-size:11px;padding:4px 10px;">&#128270; 导出AI反馈</button>
      <span class="info-tip">i<span class="info-text">导出对 AI 标记的反馈，用于改进准确度</span></span>
    </div>
  </div>
</div>

<!-- Speaker Panel -->
<div style="background:white;border-bottom:1px solid var(--gray-200);padding:8px 24px;">
  <div id="speaker-panel" style="max-width:1400px;margin:0 auto;display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
    <span class="filter-label">说话人（点击改名）:</span>
  </div>
</div>

<!-- Selection Popup (appears on mouse-drag select) -->
<div class="selection-popup" id="selection-popup" style="display:none;">
  <span class="sel-count" id="sel-count">已选 0 句</span>
  <button class="sel-delete" onclick="selectionBatchDelete()">删除</button>
  <button class="sel-restore" onclick="selectionBatchRestore()">恢复</button>
</div>

<!-- Transcript -->
<div class="transcript" id="transcript"></div>

<!-- Scroll to top -->
<button class="scroll-top" id="scroll-top" onclick="window.scrollTo({top:0,behavior:'smooth'})">&#8593;</button>

<!-- Undo toast -->
<div class="undo-toast" id="undo-toast">已撤销</div>

<script>
// ===== DELETE SEGMENTS (for original->cut time mapping) =====
const deleteSegments = [{"start": 0, "end": 67.82}, {"start": 85.06, "end": 87.34}, {"start": 176.09, "end": 177.89}, {"start": 205.18, "end": 211.66}, {"start": 249.51, "end": 249.79}, {"start": 284.19, "end": 731.36}, {"start": 738.88, "end": 739.16}, {"start": 754.73, "end": 755.45}, {"start": 856.92, "end": 858.36}, {"start": 1021.1, "end": 1021.54}, {"start": 1055, "end": 1055.56}, {"start": 1113.49, "end": 1114.45}, {"start": 1240.18, "end": 1240.74}, {"start": 1245.66, "end": 1246.7}, {"start": 1259.6, "end": 1260.08}, {"start": 1309.29, "end": 1309.97}, {"start": 1319.59, "end": 1320.35}, {"start": 1326.99, "end": 1327.91}, {"start": 1336.11, "end": 1336.83}, {"start": 1344.87, "end": 1345.27}, {"start": 1359.2, "end": 1359.8}, {"start": 1381.36, "end": 1382.04}, {"start": 1438.95, "end": 1439.43}, {"start": 1478.81, "end": 1479.17}, {"start": 1595.44, "end": 1596.88}, {"start": 1665.14, "end": 1665.5}, {"start": 1672.9, "end": 1673.38}, {"start": 1805.28, "end": 1806.12}, {"start": 1872.3, "end": 1873.02}, {"start": 1874.25, "end": 1874.45}, {"start": 2021.26, "end": 2021.94}, {"start": 2121.98, "end": 2122.98}, {"start": 2189.81, "end": 2230.38}, {"start": 2298.47, "end": 2298.91}, {"start": 2319.07, "end": 2448.31}, {"start": 2492.18, "end": 2492.62}, {"start": 2515.74, "end": 2516.06}, {"start": 2634.4, "end": 2635.44}, {"start": 2652.77, "end": 2653.17}, {"start": 2653.77, "end": 2654.13}, {"start": 2660.81, "end": 2661.25}, {"start": 2743.61, "end": 2743.73}, {"start": 2755.96, "end": 2756.6}, {"start": 2760.24, "end": 2760.52}, {"start": 2791.38, "end": 2791.82}, {"start": 2822.02, "end": 2822.18}, {"start": 2863.41, "end": 2923.28}, {"start": 2936.4, "end": 2936.72}, {"start": 2970.1, "end": 2970.34}, {"start": 3024.62, "end": 3024.86}, {"start": 3054.09, "end": 3054.57}, {"start": 3082.45, "end": 3082.65}, {"start": 3089.33, "end": 3089.73}, {"start": 3157.35, "end": 3158.03}, {"start": 3452.76, "end": 3452.88}, {"start": 3484.86, "end": 3485.46}, {"start": 3562.84, "end": 3563.04}, {"start": 3652.18, "end": 3653.22}, {"start": 3749.76, "end": 3750.08}, {"start": 3762.13, "end": 3762.45}, {"start": 3845.05, "end": 3845.25}, {"start": 3867.19, "end": 3867.31}, {"start": 3922.03, "end": 3922.23}, {"start": 4044.33, "end": 4044.93}, {"start": 4218.02, "end": 4218.1}, {"start": 4230.14, "end": 4230.7}, {"start": 4234.18, "end": 4234.46}, {"start": 4374.82, "end": 4380.78}, {"start": 4392.6, "end": 4397.04}, {"start": 4437.23, "end": 4437.71}, {"start": 4797.58, "end": 4798.22}, {"start": 4892.43, "end": 4894.39}, {"start": 4977.43, "end": 4978.19}, {"start": 5177.29, "end": 5179.17}, {"start": 5339.18, "end": 5340.06}, {"start": 5454.62, "end": 5455.39}, {"start": 5561.47, "end": 5562.67}, {"start": 5635.83, "end": 5636.35}, {"start": 5674.41, "end": 5677.25}, {"start": 5699.64, "end": 5700.04}, {"start": 5724.26, "end": 5724.54}, {"start": 5745.66, "end": 5746.14}, {"start": 5753.21, "end": 5767.43}, {"start": 5785.11, "end": 5785.87}, {"start": 5967.51, "end": 5968.11}, {"start": 6029.96, "end": 6030.16}, {"start": 6045.65, "end": 6045.97}, {"start": 6126.3, "end": 6126.46}, {"start": 6154.01, "end": 6154.21}, {"start": 6177.75, "end": 6178.91}, {"start": 6184.19, "end": 6185.07}, {"start": 6232.87, "end": 6234.59}, {"start": 6382.61, "end": 6382.77}, {"start": 6402.83, "end": 6405.55}, {"start": 6457.22, "end": 6457.58}, {"start": 6482.9, "end": 6483.42}, {"start": 6616.57, "end": 6618.33}, {"start": 6623.5, "end": 6692.44}, {"start": 6749.04, "end": 6749.44}, {"start": 6784.64, "end": 6784.84}, {"start": 6802.52, "end": 6802.8}, {"start": 6811.96, "end": 6812.52}, {"start": 6830.68, "end": 6831.96}, {"start": 6849.52, "end": 6850.04}, {"start": 6887.38, "end": 6887.58}, {"start": 6965.99, "end": 6966.43}, {"start": 6994.94, "end": 6995.1}, {"start": 7071.92, "end": 7072.12}, {"start": 7135.56, "end": 7147.04}, {"start": 7147.56, "end": 7150.36}, {"start": 7187.71, "end": 7187.95}, {"start": 7214.84, "end": 7216.36}, {"start": 7260.16, "end": 7307.84}, {"start": 7574.95, "end": 7576.43}];

// originalToCutTime replaced by dynamic originalToVirtual() in audio player

// ===== DATA =====
const sentencesData = __SENTENCES_DATA__;

const blocksData = __BLOCKS_DATA__;

const typeLabels = {"pre_show": "录前准备", "tech_debug": "技术调试", "chit_chat": "跑题闲聊", "repeated_content": "重复内容", "production_talk": "制作讨论", "privacy": "隐私保护", "redundant_viewpoint": "重复观点", "over_detail": "过度展开", "low_density": "低密度", "weak_relevance": "弱相关"};
const typeColors = {"pre_show": "#6b7280", "tech_debug": "#0891b2", "chit_chat": "#d97706", "repeated_content": "#7c3aed", "production_talk": "#2563eb", "privacy": "#dc2626", "redundant_viewpoint": "#f59e0b", "over_detail": "#f97316", "low_density": "#a3a3a3", "weak_relevance": "#78716c"};

const AI_DELETED_COUNT = __AI_DELETED_COUNT__;
const AI_SUGGESTED_COUNT = __AI_SUGGESTED_COUNT__;
const TOTAL_SENTENCES = __TOTAL_SENTENCES__;

// ===== STATE =====
let currentFilter = 'all';
let currentTypeFilter = 'all';
let searchQuery = '';
let highlightedIdx = -1;

// Track user modifications
// aiDeletedSet: the original set of AI-deleted sentence indices (includes both confirmed and suggested)
const aiDeletedSet = new Set(sentencesData.filter(s => s.isAiDeleted).map(s => s.idx));
// suggestedDeleteSet: sentences that are suggested deletions (quality optimization, not confirmed)
const suggestedDeleteSet = new Set(sentencesData.filter(s => s.isSuggestedDelete).map(s => s.idx));
// currentDeletedSet: current state of deletions (starts as copy of AI — suggested are also deleted by default)
const currentDeletedSet = new Set(aiDeletedSet);
// Track which sentences user has manually changed
const userAddedDeletions = new Set();   // user added these to deletion
const userRemovedDeletions = new Set(); // user removed these from deletion

// Fine edits state
const fineEditsOriginal = new Set(); // indices of fine edits that were originally active
const fineEditsDisabled = new Set(); // fine edit indices user disabled
const fineEditsReEnabled = new Set(); // fine edit indices user re-enabled (if any start disabled)
sentencesData.forEach(s => {
  if (s.fineEdit !== undefined) {
    fineEditsOriginal.add(s.fineEdit.idx);
  }
});

// Undo stack
const undoStack = [];

// ===== BUILD TRANSCRIPT =====
function buildTranscript() {
  const container = document.getElementById('transcript');
  let html = '';

  // Build a set of block start indices for efficient lookup
  const blockStartMap = {};
  blocksData.forEach(b => { blockStartMap[b.range[0]] = b; });

  sentencesData.forEach(s => {
    // Check if this is the start of a block
    const block = blockStartMap[s.idx];
    if (block) {
      const color = typeColors[block.type] || '#6b7280';
      const label = typeLabels[block.type] || block.type;
      const isSuggestedBlock = block.confidence === 'suggested';
      const blockBarClass = isSuggestedBlock ? 'block-bar suggested-block' : 'block-bar';
      html += `<div class="${blockBarClass}" id="block-${block.id}" data-block-id="${block.id}" data-type="${block.type}">`;
      html += `<span class="block-bar-icon">${isSuggestedBlock ? '&#128161;' : '&#9888;'}</span>`;
      html += `<span class="block-bar-id">#${block.id}</span>`;
      html += `<span class="block-bar-type" style="background:${color}">${label}</span>`;
      html += `<span class="block-bar-reason">${escapeHtml(block.reason)}</span>`;
      html += `<span class="block-bar-duration">${block.duration}</span>`;
      html += `</div>`;
    }

    const isDeleted = currentDeletedSet.has(s.idx);
    const isUserModified = userAddedDeletions.has(s.idx) || userRemovedDeletions.has(s.idx);
    const isAiDel = aiDeletedSet.has(s.idx);

    let rowClass = 'sentence-row';
    if (isDeleted) rowClass += ' deleted';
    if (isDeleted && suggestedDeleteSet.has(s.idx) && !userAddedDeletions.has(s.idx)) rowClass += ' suggested-delete';
    if (isUserModified) rowClass += ' user-modified';

    const spClass = __SPEAKER_CLASS_FUNC__;

    html += `<div class="${rowClass}" id="row-${s.idx}" data-idx="${s.idx}" onclick="highlightRow(${s.idx})">`;

    // Index
    html += `<div class="s-idx">${s.idx}</div>`;

    // Speaker
    html += `<div class="s-speaker ${spClass}">${escapeHtml(s.speaker)}</div>`;

    // Time
    html += `<div class="s-time" onclick="event.stopPropagation(); seekToTime(${s.startTime})">${s.timeStr}</div>`;

    // Text with fine edit markers
    let textHtml = '';

    if (s.fineEdit) {
      const fe = s.fineEdit;
      const feDisabled = fineEditsDisabled.has(fe.idx);
      const feClass = feDisabled ? 'fine-tag disabled' : 'fine-tag';
      const delClass = feDisabled ? 'fine-delete disabled' : 'fine-delete';

      if (fe.type === 'silence') {
        const dur = (fe.de || 0) - (fe.ds || 0);
        const deleteDur = Math.max(0, dur - 0.8);
        const pauseClass = feDisabled ? 'silence-pause disabled' : 'silence-pause';
        textHtml += escapeHtml(s.text);
        textHtml += ` <span class="${pauseClass}" data-fine-idx="${fe.idx}" onclick="event.stopPropagation(); toggleFineEdit(${fe.idx})" title="静音${dur.toFixed(1)}s → 保留0.8s，删${deleteDur.toFixed(1)}s — 点击切换">-${deleteDur.toFixed(1)}s</span>`;
      } else {
        textHtml += `<span class="${feClass}" data-fine-idx="${fe.idx}" onclick="event.stopPropagation(); toggleFineEdit(${fe.idx})" title="${escapeHtml(fe.reason)}">${escapeHtml(fe.type)}</span>`;

        // Show text with deletion marked (clickable to toggle)
        // 优先用 charOffset（精确），回退到 indexOf（可能误匹配同字）
        if (fe.deleteText) {
          const escapedText = escapeHtml(s.text);
          const escapedDel = escapeHtml(fe.deleteText);
          const pos = (fe.charOffset !== undefined) ? fe.charOffset : escapedText.indexOf(escapedDel);
          if (pos >= 0 && pos + escapedDel.length <= escapedText.length) {
            textHtml += escapedText.substring(0, pos);
            textHtml += `<span class="${delClass}" onclick="event.stopPropagation(); toggleFineEdit(${fe.idx})" title="点击切换保留/删除">${escapedDel}</span>`;
            textHtml += escapedText.substring(pos + escapedDel.length);
          } else {
            textHtml += escapedText;
          }
        } else {
          textHtml += escapeHtml(s.text);
        }
      }
    } else {
      textHtml += escapeHtml(s.text);
    }

    // Render extraSilences bars after the text
    if (s.extraSilences && s.extraSilences.length > 0) {
      s.extraSilences.forEach(es => {
        const esDisabled = fineEditsDisabled.has(es.idx);
        const esDur = (es.de || 0) - (es.ds || 0);
        const esDeleteDur = Math.max(0, esDur - 0.8);
        const esPauseClass = esDisabled ? 'silence-pause disabled' : 'silence-pause';
        textHtml += ` <span class="${esPauseClass}" data-fine-idx="${es.idx}" onclick="event.stopPropagation(); toggleFineEdit(${es.idx})" title="静音${esDur.toFixed(1)}s → 保留0.8s，删${esDeleteDur.toFixed(1)}s — 点击切换">[...${esDur.toFixed(1)}s]</span>`;
      });
    }

    const textClass = isDeleted ? 's-text deleted-text' : 's-text';
    html += `<div class="${textClass}">${textHtml}</div>`;

    // Badges
    html += `<div class="s-badges">`;
    if (isAiDel && suggestedDeleteSet.has(s.idx)) {
      html += `<span class="ai-badge" style="background:#f59e0b">建议</span>`;
    } else if (isAiDel) {
      html += `<span class="ai-badge">AI</span>`;
    }
    if (isDeleted && s.deleteType) {
      const color = typeColors[s.deleteType] || '#6b7280';
      const label = typeLabels[s.deleteType] || s.deleteType;
      html += `<span class="tag" style="background:${color}">${label}</span>`;
    }
    html += `</div>`;

    html += `</div>`;
  });

  container.innerHTML = html;
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ===== TOGGLE DELETION =====

// ===== MOUSE-DRAG BATCH SELECTION =====
let _selectionRowIndices = [];

function getSelectedRowIndices() {
  const sel = window.getSelection();
  if (!sel || sel.isCollapsed) return [];

  const range = sel.getRangeAt(0);
  const transcript = document.getElementById('transcript');
  if (!transcript) return [];

  // Find all sentence rows that intersect with the selection
  const indices = [];
  const rows = transcript.querySelectorAll('.sentence-row');
  for (const row of rows) {
    if (row.classList.contains('hidden')) continue;
    if (range.intersectsNode(row)) {
      const idx = parseInt(row.dataset.idx);
      if (!isNaN(idx)) indices.push(idx);
    }
  }
  return indices;
}

function showSelectionPopup() {
  const indices = getSelectedRowIndices();
  _selectionRowIndices = indices;
  const popup = document.getElementById('selection-popup');
  if (indices.length < 2) {
    popup.style.display = 'none';
    return;
  }

  document.getElementById('sel-count').textContent = '已选 ' + indices.length + ' 句';

  // Position near the end of selection
  const sel = window.getSelection();
  if (sel.rangeCount > 0) {
    const rng = sel.getRangeAt(0);
    const rect = rng.getBoundingClientRect();
    let top = rect.bottom + 8;
    let left = rect.left + (rect.width / 2) - 100;
    // Keep within viewport
    if (top + 50 > window.innerHeight) top = rect.top - 50;
    if (left < 8) left = 8;
    if (left + 220 > window.innerWidth) left = window.innerWidth - 228;
    popup.style.top = top + 'px';
    popup.style.left = left + 'px';
  }
  popup.style.display = 'flex';
}

function hideSelectionPopup() {
  const popup = document.getElementById('selection-popup');
  if (popup) popup.style.display = 'none';
  _selectionRowIndices = [];
}

function selectionBatchDelete() {
  if (_selectionRowIndices.length === 0) return;
  const deletedIndices = [];
  const batchUndo = [];
  _selectionRowIndices.forEach(sIdx => {
    if (!currentDeletedSet.has(sIdx)) {
      batchUndo.push({ type: 'deletion', idx: sIdx, wasDeleted: false });
      currentDeletedSet.add(sIdx);
      if (!aiDeletedSet.has(sIdx)) { userAddedDeletions.add(sIdx); }
      userRemovedDeletions.delete(sIdx);
      updateRowVisual(sIdx);
      deletedIndices.push(sIdx);
    }
  });
  if (batchUndo.length > 0) {
    undoStack.push({ type: 'batch', items: batchUndo });
    _showSaveIndicator('✓ 批量删除 ' + batchUndo.length + ' 句');
  }
  updateStats();
  window.getSelection().removeAllRanges();
  hideSelectionPopup();

  // Show feedback panel for batch deletion
  if (deletedIndices.length > 0) {
    const firstIdx = deletedIndices[0];
    const lastIdx = deletedIndices[deletedIndices.length - 1];
    const firstSent = sentencesData.find(s => s.idx === firstIdx);
    const lastSent = sentencesData.find(s => s.idx === lastIdx);
    const previewText = deletedIndices.length === 1
      ? (firstSent ? firstSent.text : '')
      : (firstSent ? firstSent.text.slice(0, 30) : '') + '… → …' + (lastSent ? lastSent.text.slice(-30) : '');
    const displayText = previewText.length > 80 ? previewText.slice(0, 80) + '...' : previewText;

    _mcPendingText = deletedIndices.map(idx => {
      const s = sentencesData.find(x => x.idx === idx);
      return s ? s.text : '';
    }).join(' ');
    _mcPendingSentenceIdx = firstIdx;
    _mcPendingBatchIndices = deletedIndices.slice();

    document.getElementById('mc-preview-text').textContent = displayText;
    document.getElementById('mc-reason').value = '';
    const panel = document.getElementById('missed-catch-panel');
    const firstRow = document.getElementById('row-' + firstIdx);
    if (firstRow) {
      const rowRect = firstRow.getBoundingClientRect();
      panel.style.left = Math.min(rowRect.left + 40, window.innerWidth - 340) + 'px';
      panel.style.top = (rowRect.bottom + 4) + 'px';
    }
    panel.classList.add('visible');
    setTimeout(() => document.getElementById('mc-type').focus(), 100);
  }
}

function selectionBatchRestore() {
  if (_selectionRowIndices.length === 0) return;
  const batchUndo = [];
  _selectionRowIndices.forEach(sIdx => {
    if (currentDeletedSet.has(sIdx)) {
      batchUndo.push({ type: 'deletion', idx: sIdx, wasDeleted: true });
      currentDeletedSet.delete(sIdx);
      if (aiDeletedSet.has(sIdx)) { userRemovedDeletions.add(sIdx); }
      userAddedDeletions.delete(sIdx);
      updateRowVisual(sIdx);
    }
  });
  if (batchUndo.length > 0) {
    undoStack.push({ type: 'batch', items: batchUndo });
    _showSaveIndicator('✓ 批量恢复 ' + batchUndo.length + ' 句');
  }
  updateStats();
  window.getSelection().removeAllRanges();
  hideSelectionPopup();
}

// Listen for mouseup on transcript to detect selection
document.addEventListener('mouseup', function(e) {
  // Don't trigger if clicking inside the popup itself
  const popup = document.getElementById('selection-popup');
  if (popup && popup.contains(e.target)) return;

  // Small delay to let selection finalize
  setTimeout(showSelectionPopup, 50);
});

// Hide popup when clicking elsewhere (not on popup)
document.addEventListener('mousedown', function(e) {
  const popup = document.getElementById('selection-popup');
  if (popup && popup.style.display !== 'none' && !popup.contains(e.target)) {
    hideSelectionPopup();
  }
});

function toggleDeletion(idx) {
  // Save undo state
  undoStack.push({
    type: 'deletion',
    idx: idx,
    wasDeleted: currentDeletedSet.has(idx)
  });

  const isCurrentlyDeleted = currentDeletedSet.has(idx);
  const isAiDel = aiDeletedSet.has(idx);
  const isRestoring = isCurrentlyDeleted; // un-deleting = restoring

  if (isCurrentlyDeleted) {
    // Un-delete
    currentDeletedSet.delete(idx);
    if (isAiDel) {
      userRemovedDeletions.add(idx);
      userAddedDeletions.delete(idx);
    } else {
      userAddedDeletions.delete(idx);
    }
  } else {
    // Delete
    currentDeletedSet.add(idx);
    if (!isAiDel) {
      userAddedDeletions.add(idx);
      userRemovedDeletions.delete(idx);
    } else {
      userRemovedDeletions.delete(idx);
    }
  }

  updateRowVisual(idx);
  updateStats();

  // Show restore feedback panel when restoring
  if (isRestoring) {
    const sent = sentencesData.find(s => s.idx === idx);
    showRestorePanel({
      editType: 'sentence',
      sentenceIdx: idx,
      text: sent ? sent.text : '句子 ' + idx
    });
  }
}

function updateRowVisual(idx) {
  const row = document.getElementById('row-' + idx);
  if (!row) return;

  const isDeleted = currentDeletedSet.has(idx);
  const isUserModified = userAddedDeletions.has(idx) || userRemovedDeletions.has(idx);

  row.classList.toggle('deleted', isDeleted);
  row.classList.toggle('user-modified', isUserModified);

  // Update text styling
  const textEl = row.querySelector('.s-text');
  if (textEl) {
    textEl.classList.toggle('deleted-text', isDeleted);
  }

  // Apply filter visibility
  applyFilters();
  invalidateSkipRanges();
}

// ===== TOGGLE FINE EDIT =====
function toggleFineEdit(feIdx) {
  // Don't toggle if user is drag-selecting text (not a simple click)
  const sel = window.getSelection();
  if (sel && !sel.isCollapsed && sel.toString().trim().length > 0) return;

  const wasDisabled = fineEditsDisabled.has(feIdx);
  undoStack.push({
    type: 'fineEdit',
    feIdx: feIdx,
    wasDisabled: wasDisabled
  });

  if (wasDisabled) {
    fineEditsDisabled.delete(feIdx);
  } else {
    fineEditsDisabled.add(feIdx);
  }

  invalidateSkipRanges();
  const s = sentencesData.find(s =>
    (s.fineEdit && s.fineEdit.idx === feIdx) ||
    (s.extraSilences && s.extraSilences.some(es => es.idx === feIdx)) ||
    (s.extraFineEdits && s.extraFineEdits.some(ef => ef.idx === feIdx))
  );
  if (s) {
    rebuildRowText(s);
  }
  updateStats();
  autoSave();

  // Show restore feedback when disabling a fine edit (= restoring deleted content)
  if (!wasDisabled && s) {
    // Find the fine edit to get its delete text
    let feText = '';
    if (s.fineEdit && s.fineEdit.idx === feIdx) feText = s.fineEdit.deleteText || s.fineEdit.type;
    else if (s.extraFineEdits) {
      const ef = s.extraFineEdits.find(ef => ef.idx === feIdx);
      if (ef) feText = ef.deleteText || ef.type;
    }
    if (s.extraSilences) {
      const es = s.extraSilences.find(es => es.idx === feIdx);
      if (es) feText = '静音 ' + ((es.end - es.start) || 0).toFixed(1) + 's';
    }
    showRestorePanel({
      editType: 'fine',
      sentenceIdx: s.idx,
      text: feText || '精剪编辑 #' + feIdx
    });
  }
}

function rebuildRowText(s) {
  const row = document.getElementById('row-' + s.idx);
  if (!row) return;
  const textEl = row.querySelector('.s-text');
  if (!textEl || !s.fineEdit) return;

  const fe = s.fineEdit;
  const feDisabled = fineEditsDisabled.has(fe.idx);

  let textHtml = '';
  const feClass = feDisabled ? 'fine-tag disabled' : 'fine-tag';
  const delClass = feDisabled ? 'fine-delete disabled' : 'fine-delete';

  if (fe.type === 'silence') {
    const dur = (fe.de || 0) - (fe.ds || 0);
    const deleteDur = Math.max(0, dur - 0.8);
    const pauseClass = feDisabled ? 'silence-pause disabled' : 'silence-pause';
    textHtml += escapeHtml(s.text);
    textHtml += ` <span class="${pauseClass}" data-fine-idx="${fe.idx}" onclick="event.stopPropagation(); toggleFineEdit(${fe.idx})" title="静音${dur.toFixed(1)}s → 保留0.8s，删${deleteDur.toFixed(1)}s — 点击切换">-${deleteDur.toFixed(1)}s</span>`;
  } else {
    textHtml += `<span class="${feClass}" data-fine-idx="${fe.idx}" onclick="event.stopPropagation(); toggleFineEdit(${fe.idx})" title="${escapeHtml(fe.reason)}">${escapeHtml(fe.type)}</span>`;

    if (fe.deleteText) {
      const escapedText = escapeHtml(s.text);
      const escapedDel = escapeHtml(fe.deleteText);
      const pos = (fe.charOffset !== undefined) ? fe.charOffset : escapedText.indexOf(escapedDel);
      if (pos >= 0 && pos + escapedDel.length <= escapedText.length) {
        textHtml += escapedText.substring(0, pos);
        textHtml += `<span class="${delClass}" onclick="event.stopPropagation(); toggleFineEdit(${fe.idx})" title="点击切换保留/删除">${escapedDel}</span>`;
        textHtml += escapedText.substring(pos + escapedDel.length);
      } else {
        textHtml += escapedText;
      }
    } else {
      textHtml += escapeHtml(s.text);
    }
  }

  // Render extraSilences bars
  if (s.extraSilences && s.extraSilences.length > 0) {
    s.extraSilences.forEach(es => {
      const esDisabled = fineEditsDisabled.has(es.idx);
      const esDur = (es.de || 0) - (es.ds || 0);
      const esDeleteDur = Math.max(0, esDur - 0.8);
      const esBarClass = esDisabled ? 'silence-bar disabled' : 'silence-bar';
      const esBarText = esDeleteDur > 0 ? `····${esDeleteDur.toFixed(1)}s····` : `····${esDur.toFixed(1)}s····`;
      textHtml += ` <span class="${esBarClass}" data-fine-idx="${es.idx}" onclick="event.stopPropagation(); toggleFineEdit(${es.idx})" title="静音${esDur.toFixed(1)}s → 保留0.8s，删${esDeleteDur.toFixed(1)}s — 点击切换">${esBarText}</span>`;
    });
  }

  textEl.innerHTML = textHtml;
}

// ===== UPDATE STATS =====
function updateStats() {
  const addCount = userAddedDeletions.size;
  const removeCount = userRemovedDeletions.size;
  const finalDelete = currentDeletedSet.size;

  document.getElementById('stat-user-add').textContent = '+' + addCount;
  document.getElementById('stat-user-remove').textContent = '-' + removeCount;
  document.getElementById('stat-final-delete').textContent = finalDelete;
  updateSummaryFooter();
  autoSave();
}

// ===== AUTO-SAVE (localStorage) =====
const _SAVE_KEY = 'podcastcut_review_' + btoa(unescape(encodeURIComponent(document.title))).slice(0, 40);
const _GEN_TS = __GEN_TIMESTAMP__; // template generation timestamp, injected by generate script
let _saveTimer = null;
let _hasUnsavedEdits = false;

function autoSave() {
  // Debounce: save 500ms after last edit
  _hasUnsavedEdits = true;
  if (_saveTimer) clearTimeout(_saveTimer);
  _saveTimer = setTimeout(_doSave, 500);
}

function _doSave() {
  try {
    const state = {
      v: 3,
      ts: Date.now(),
      userAdded: Array.from(userAddedDeletions),
      userRemoved: Array.from(userRemovedDeletions),
      fineEditsDisabled: Array.from(fineEditsDisabled),
      manualEdits: manualEdits.map(e => ({
        id: e.id, sentenceIdx: e.sentenceIdx,
        deleteText: e.deleteText, disabled: e.disabled,
        charOffset: e.charOffset
      })),
      manualEditCounter: manualEditCounter,
      missedCatches: missedCatches.slice(),
      comments: comments.slice(),
      commentCounter: commentCounter,
      restoreFeedback: restoreFeedback.slice(),
      restoreFeedbackCounter: restoreFeedbackCounter,
      speakerModifications: Object.keys(speakerModifications).length > 0 ? Object.assign({}, speakerModifications) : undefined
    };
    localStorage.setItem(_SAVE_KEY, JSON.stringify(state));
    console.log('[save] saved', JSON.stringify(state).length, 'bytes, userAdded:', state.userAdded.length, 'userRemoved:', state.userRemoved.length);
    _hasUnsavedEdits = false;
    _showSaveIndicator();
  } catch (e) {
    console.warn('Auto-save failed:', e);
  }
}

function _showSaveIndicator() {
  let badge = document.getElementById('save-badge');
  if (!badge) {
    badge = document.createElement('span');
    badge.id = 'save-badge';
    badge.style.cssText = 'font-size:11px;color:#16a34a;margin-left:8px;opacity:0;transition:opacity 0.3s;';
    // Insert after export buttons in audio bar
    const exportBtn = document.querySelector('.export-btn');
    if (exportBtn) exportBtn.parentElement.appendChild(badge);
  }
  badge.textContent = '\u2713 已自动保存';
  badge.style.opacity = '1';
  setTimeout(() => { badge.style.opacity = '0'; }, 2000);
}

function restoreState() {
  try {
    const raw = localStorage.getItem(_SAVE_KEY);
    console.log('[restore] key=', _SAVE_KEY, 'raw=', raw ? raw.length + ' bytes' : 'null');
    if (!raw) return false;
    const state = JSON.parse(raw);
    if (!state || (state.v !== 2 && state.v !== 3)) return false;

    // Check if state is stale (> 30 days)
    if (Date.now() - state.ts > 30 * 86400000) {
      localStorage.removeItem(_SAVE_KEY);
      return false;
    }

    let changed = false;

    // Restore sentence deletions
    if (state.userAdded && state.userAdded.length > 0) {
      state.userAdded.forEach(idx => {
        if (!aiDeletedSet.has(idx)) {
          currentDeletedSet.add(idx);
          userAddedDeletions.add(idx);
          changed = true;
        }
      });
    }
    if (state.userRemoved && state.userRemoved.length > 0) {
      state.userRemoved.forEach(idx => {
        if (aiDeletedSet.has(idx)) {
          currentDeletedSet.delete(idx);
          userRemovedDeletions.add(idx);
          changed = true;
        }
      });
    }

    // Restore fine edit toggles (only from saves AFTER this HTML was generated;
    // old saves may have stale disabled entries from previous buggy UI)
    if (state.fineEditsDisabled && state.fineEditsDisabled.length > 0 && state.ts >= _GEN_TS) {
      state.fineEditsDisabled.forEach(feIdx => {
        if (fineEditsOriginal.has(feIdx)) {
          fineEditsDisabled.add(feIdx);
          changed = true;
        }
      });
    }

    // Restore manual edits
    if (state.manualEdits && state.manualEdits.length > 0) {
      state.manualEdits.forEach(me => {
        manualEdits.push({
          id: me.id,
          sentenceIdx: me.sentenceIdx,
          deleteText: me.deleteText,
          disabled: me.disabled || false
        });
      });
      manualEditCounter = state.manualEditCounter || manualEdits.length;
      changed = true;
    }

    // Restore missed catches
    if (state.missedCatches && state.missedCatches.length > 0) {
      state.missedCatches.forEach(mc => missedCatches.push(mc));
      missedCatchCounter = missedCatches.length;
    }

    // Restore speaker modifications
    if (state.speakerModifications) {
      Object.keys(state.speakerModifications).forEach(idxStr => {
        const idx = parseInt(idxStr);
        const newSpeaker = state.speakerModifications[idxStr];
        const sent = sentencesData.find(s => s.idx === idx);
        if (sent) {
          sent.speaker = newSpeaker;
          speakerModifications[idx] = newSpeaker;
          changed = true;
        }
      });
    }

    // Restore comments (v3+)
    if (state.comments && state.comments.length > 0) {
      state.comments.forEach(c => comments.push(c));
      commentCounter = state.commentCounter || comments.length;
      changed = true;
    }

    // Restore restore feedback (v3+)
    if (state.restoreFeedback && state.restoreFeedback.length > 0) {
      state.restoreFeedback.forEach(rf => restoreFeedback.push(rf));
      restoreFeedbackCounter = state.restoreFeedbackCounter || restoreFeedback.length;
    }

    if (changed) {
      // Rebuild all affected rows
      sentencesData.forEach(s => {
        updateRowVisual(s.idx);
        rebuildRowWithManualEdits(s.idx);
      });
      buildSummaryTable();
      invalidateSkipRanges();
      updateStats();

      // Show restore notification
      const age = Math.round((Date.now() - state.ts) / 60000);
      const ageText = age < 1 ? '刚刚' : age < 60 ? age + '分钟前' : Math.round(age/60) + '小时前';
      const toast = document.createElement('div');
      toast.style.cssText = 'position:fixed;top:80px;right:20px;background:#1a3a1a;color:#a3e635;padding:12px 20px;border-radius:8px;z-index:9999;font-size:13px;box-shadow:0 4px 12px rgba(0,0,0,0.3);transition:opacity 0.5s;';
      toast.textContent = '\u2713 已恢复上次编辑（' + ageText + '保存）';
      document.body.appendChild(toast);
      setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 500); }, 3000);
    }

    return changed;
  } catch (e) {
    console.warn('Restore failed:', e);
    return false;
  }
}

// ===== SUMMARY TABLE =====
function fmtDur(sec) {
  sec = Math.round(sec);
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  return h > 0 ? h + ':' + String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0') : m + ':' + String(s).padStart(2,'0');
}

function extractTopic(reason) {
  const sep = reason.indexOf('\uff1a');
  if (sep > 0 && sep < 25) return reason.substring(0, sep);
  const sep2 = reason.indexOf('\u2014\u2014');
  if (sep2 > 0 && sep2 < 25) return reason.substring(0, sep2);
  return reason.length > 20 ? reason.substring(0, 20) + '\u2026' : reason;
}

function extractDetail(reason) {
  const sep = reason.indexOf('\uff1a');
  if (sep > 0) return reason.substring(sep + 1);
  const sep2 = reason.indexOf('\u2014\u2014');
  if (sep2 > 0) return reason.substring(sep2 + 2);
  return reason;
}

function getBlockTimeInfo(block) {
  const startSent = sentencesData.find(s => s.idx === block.range[0]);
  const endSent = sentencesData.find(s => s.idx === block.range[1]);
  const st = startSent ? startSent.startTime : 0;
  const et = endSent ? endSent.endTime : 0;
  return { startTime: st, endTime: et, duration: et - st };
}

function isBlockFullyDeleted(block) {
  for (let i = block.range[0]; i <= block.range[1]; i++) {
    const sent = sentencesData.find(s => s.idx === i);
    if (sent && !currentDeletedSet.has(i)) return false;
  }
  return true;
}

function buildSummaryTable() {
  const tbody = document.getElementById('summary-tbody');
  // Sort blocks chronologically
  const sorted = [...blocksData].sort((a, b) => a.range[0] - b.range[0]);
  let html = '';
  sorted.forEach(block => {
    const info = getBlockTimeInfo(block);
    const topic = extractTopic(block.reason);
    const detail = extractDetail(block.reason);
    const color = typeColors[block.type] || '#6b7280';
    const typeLabel = typeLabels[block.type] || block.type;
    const checked = isBlockFullyDeleted(block);
    html += '<tr id="summary-row-' + block.id + '" class="' + (checked ? '' : 'block-unchecked') + '">';
    html += '<td class="st-check"><input type="checkbox" ' + (checked ? 'checked' : '') + ' onchange="toggleBlockDeletion(' + block.id + ', this.checked)"></td>';
    html += '<td class="st-id">' + block.id + '</td>';
    html += '<td class="st-topic">' + escapeHtml(topic) + '</td>';
    const suggestedTag = block.confidence === 'suggested' ? ' <span style="font-size:10px;color:#d97706;font-weight:600">建议</span>' : '';
    html += '<td class="st-type"><span class="summary-type-tag" style="background:' + color + '">' + typeLabel + '</span>' + suggestedTag + '</td>';
    html += '<td class="st-pos" onclick="seekToTime(' + info.startTime + ')">' + fmtDur(info.startTime) + '</td>';
    html += '<td class="st-dur">' + fmtDur(info.duration) + '</td>';
    html += '<td class="st-reason">' + escapeHtml(detail) + '</td>';
    html += '</tr>';
  });
  tbody.innerHTML = html;
  updateSummaryFooter();
}

function toggleBlockDeletion(blockId, checked) {
  const block = blocksData.find(b => b.id === blockId);
  if (!block) return;

  // Batch undo: save state for all sentences in block
  const batchUndo = [];
  for (let i = block.range[0]; i <= block.range[1]; i++) {
    const sent = sentencesData.find(s => s.idx === i);
    if (!sent) continue;
    batchUndo.push({ idx: i, wasDeleted: currentDeletedSet.has(i) });
  }
  undoStack.push({ type: 'batch', items: batchUndo });

  // Apply
  for (let i = block.range[0]; i <= block.range[1]; i++) {
    const sent = sentencesData.find(s => s.idx === i);
    if (!sent) continue;
    if (checked) {
      currentDeletedSet.add(i);
    } else {
      currentDeletedSet.delete(i);
    }
  }

  rederiveUserMods();

  // Update row visuals for all sentences in block
  for (let i = block.range[0]; i <= block.range[1]; i++) {
    updateRowVisual(i);
  }

  // Update summary row visual
  const row = document.getElementById('summary-row-' + blockId);
  if (row) row.className = checked ? '' : 'block-unchecked';

  // Update header checkbox
  updateSummaryCheckAll();
  updateStats();
}

function toggleAllBlocks(checked) {
  blocksData.forEach(block => {
    const row = document.getElementById('summary-row-' + block.id);
    if (row) {
      const cb = row.querySelector('input[type="checkbox"]');
      if (cb && cb.checked !== checked) {
        cb.checked = checked;
        toggleBlockDeletion(block.id, checked);
      }
    }
  });
}

function updateSummaryCheckAll() {
  const allChecked = blocksData.every(b => isBlockFullyDeleted(b));
  document.getElementById('summary-check-all').checked = allChecked;
}

function updateSummaryFooter() {
  const footer = document.getElementById('summary-footer');
  if (!footer) return;

  // Total duration from last sentence
  const totalDur = sentencesData.length > 0
    ? sentencesData[sentencesData.length - 1].endTime
    : 0;

  // Deleted duration (sentence-level only, approximate)
  let deletedDur = 0;
  sentencesData.forEach(s => {
    if (currentDeletedSet.has(s.idx)) {
      deletedDur += (s.endTime - s.startTime);
    }
  });

  // Block-level breakdown for checked blocks
  let blockDeleteDur = 0;
  const sorted = [...blocksData].sort((a, b) => a.range[0] - b.range[0]);
  sorted.forEach(block => {
    if (isBlockFullyDeleted(block)) {
      const info = getBlockTimeInfo(block);
      blockDeleteDur += info.duration;
    }
  });

  const remaining = Math.max(0, totalDur - deletedDur);

  footer.innerHTML =
    '<div class="sf-item"><span class="sf-label">原始总时长</span><span class="sf-value">' + fmtDur(totalDur) + '</span></div>' +
    '<div class="sf-item"><span class="sf-label">段落删减</span><span class="sf-value cut">' + fmtDur(blockDeleteDur) + '</span></div>' +
    '<div class="sf-item"><span class="sf-label">总删减(含精剪)</span><span class="sf-value cut">' + fmtDur(deletedDur) + '</span></div>' +
    '<div class="sf-item"><span class="sf-label">预计剩余</span><span class="sf-value result">' + fmtDur(remaining) + '</span></div>';
}

function toggleSummaryPanel() {
  const body = document.getElementById('summary-body');
  const arrow = document.getElementById('summary-arrow');
  body.classList.toggle('collapsed');
  arrow.classList.toggle('collapsed');
}

// ===== UNDO =====
function undo() {
  if (undoStack.length === 0) return;
  const action = undoStack.pop();

  if (action.type === 'deletion') {
    const idx = action.idx;
    const isAiDel = aiDeletedSet.has(idx);

    if (action.wasDeleted) {
      currentDeletedSet.add(idx);
      if (!isAiDel) {
        userAddedDeletions.add(idx);
      } else {
        userRemovedDeletions.delete(idx);
      }
    } else {
      currentDeletedSet.delete(idx);
      if (!isAiDel) {
        userAddedDeletions.delete(idx);
      } else {
        userRemovedDeletions.add(idx);
      }
    }

    // Wait... we need to be more careful. Let's just restore state exactly.
    // Actually since we're only undoing one step, let's re-derive user mod state.
    // Re-derive userAdded/Removed from currentDeleted vs aiDeleted
    rederiveUserMods();
    updateRowVisual(idx);
  } else if (action.type === 'fineEdit') {
    if (action.wasDisabled) {
      fineEditsDisabled.add(action.feIdx);
    } else {
      fineEditsDisabled.delete(action.feIdx);
    }
    const s = sentencesData.find(s => s.fineEdit && s.fineEdit.idx === action.feIdx);
    if (s) {
      rebuildRowWithManualEdits(s.idx);
    }
  } else if (action.type === 'manualEdit') {
    // Undo adding a manual edit - remove it
    const idx = manualEdits.findIndex(e => e.id === action.editId);
    if (idx >= 0) {
      const edit = manualEdits[idx];
      const sentIdx = edit.sentenceIdx;
      manualEdits.splice(idx, 1);
      rebuildRowWithManualEdits(sentIdx);
    }
  } else if (action.type === 'manualEditToggle') {
    const edit = manualEdits.find(e => e.id === action.editId);
    if (edit) {
      edit.disabled = action.wasDisabled;
      rebuildRowWithManualEdits(edit.sentenceIdx);
    }
  } else if (action.type === 'batch') {
    action.items.forEach(item => {
      if (item.wasDeleted) {
        currentDeletedSet.add(item.idx);
      } else {
        currentDeletedSet.delete(item.idx);
      }
      updateRowVisual(item.idx);
    });
    rederiveUserMods();
    buildSummaryTable();
  }

  updateStats();
  showUndoToast();
}

function rederiveUserMods() {
  userAddedDeletions.clear();
  userRemovedDeletions.clear();

  currentDeletedSet.forEach(idx => {
    if (!aiDeletedSet.has(idx)) {
      userAddedDeletions.add(idx);
    }
  });

  aiDeletedSet.forEach(idx => {
    if (!currentDeletedSet.has(idx)) {
      userRemovedDeletions.add(idx);
    }
  });

  // Update all row visuals for user-modified class
  sentencesData.forEach(s => {
    const row = document.getElementById('row-' + s.idx);
    if (row) {
      const isUserModified = userAddedDeletions.has(s.idx) || userRemovedDeletions.has(s.idx);
      row.classList.toggle('user-modified', isUserModified);
    }
  });
}

function showUndoToast() {
  const toast = document.getElementById('undo-toast');
  toast.classList.add('visible');
  setTimeout(() => toast.classList.remove('visible'), 1500);
}

// ===== EXPORT =====
function exportModifications() {
  const addedDeletions = Array.from(userAddedDeletions).sort((a,b) => a-b);
  const removedDeletions = Array.from(userRemovedDeletions).sort((a,b) => a-b);
  const disabledFE = Array.from(fineEditsDisabled).sort((a,b) => a-b);

  // Compute enabled fine edits (those originally active that are NOT disabled)
  const enabledFE = Array.from(fineEditsOriginal).filter(i => !fineEditsDisabled.has(i)).sort((a,b) => a-b);

  const finalDeleteSentences = Array.from(currentDeletedSet).sort((a,b) => a-b);

  // Build active fine edits list
  const activeFineEdits = [];
  sentencesData.forEach(s => {
    if (s.fineEdit && !fineEditsDisabled.has(s.fineEdit.idx)) {
      activeFineEdits.push({
        sentenceIdx: s.idx,
        fineEditIdx: s.fineEdit.idx,
        type: s.fineEdit.type,
        deleteText: s.fineEdit.deleteText,
        keepText: s.fineEdit.keepText
      });
    }
  });

  // Manual edits (active only)
  const activeManualEdits = manualEdits.filter(e => !e.disabled).map(e => ({
    sentenceIdx: e.sentenceIdx,
    deleteText: e.deleteText
  }));

  const exportData = {
    exported_at: new Date().toISOString(),
    modifications: {
      added_deletions: addedDeletions,
      removed_deletions: removedDeletions,
      disabled_fine_edits: disabledFE,
      enabled_fine_edits: enabledFE,
      manual_edits: activeManualEdits
    },
    final_selection: {
      delete_sentences: finalDeleteSentences,
      fine_edits: activeFineEdits,
      manual_edits: activeManualEdits
    }
  };

  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'review_modifications_' + new Date().toISOString().slice(0,10) + '.json';
  a.click();
  URL.revokeObjectURL(url);
}

// Export delete_segments.json for cut_audio.py
// Uses clean ranges (no player-specific lookahead/nudge adjustments)
function importEditState(input) {
  const file = input.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      // Support combined format (has .editState) or legacy edit-only format (has .v)
      const state = data.editState || (data.v === 2 ? data : null);
      if (!state || state.v !== 2) { alert('无效的编辑文件。请导入"导出剪辑文件"生成的 JSON。'); return; }
      localStorage.setItem(_SAVE_KEY, JSON.stringify(state));
      location.reload();
    } catch (err) {
      alert('导入失败: ' + err.message);
    }
  };
  reader.readAsText(file);
  input.value = '';
}

function exportDeleteSegments() {
  const ranges = [];

  sentencesData.forEach(s => {
    // Sentence-level deletions
    if (currentDeletedSet.has(s.idx)) {
      ranges.push([s.startTime, s.endTime]);
      return;
    }

    // Fine edits (word-level or whole-sentence)
    if (s.fineEdit && !fineEditsDisabled.has(s.fineEdit.idx)) {
      const fe = s.fineEdit;
      if (fe.wholeSentence) {
        ranges.push([s.startTime, s.endTime]);
      } else if (fe.ds !== undefined && fe.de !== undefined) {
        ranges.push([fe.ds, fe.de]);
      }
    }

    // Extra fine edits + silences
    if (s.extraFineEdits) {
      for (const efe of s.extraFineEdits) {
        if (!fineEditsDisabled.has(efe.idx) && efe.ds !== undefined && efe.de !== undefined) {
          ranges.push([efe.ds, efe.de]);
        }
      }
    }
    if (s.extraSilences) {
      for (const es of s.extraSilences) {
        if (!fineEditsDisabled.has(es.idx) && es.ds !== undefined && es.de !== undefined) {
          ranges.push([es.ds, es.de]);
        }
      }
    }

    // Manual edits (word-level)
    const sentManual = manualEdits.filter(e => e.sentenceIdx === s.idx && !e.disabled);
    for (const me of sentManual) {
      if (!s.words || s.words.length === 0) continue;
      const wordTexts = s.words.map(w => w.t);
      const fullText = wordTexts.join('');
      let pos = -1;
      if (me.charOffset !== undefined && fullText.substring(me.charOffset, me.charOffset + me.deleteText.length) === me.deleteText) {
        pos = me.charOffset;
      } else {
        pos = fullText.indexOf(me.deleteText);
      }
      if (pos < 0) continue;

      let charCount = 0, startW = null, endW = null;
      for (let i = 0; i < wordTexts.length; i++) {
        const wEnd = charCount + wordTexts[i].length;
        if (startW === null && wEnd > pos) startW = i;
        if (wEnd >= pos + me.deleteText.length) { endW = i; break; }
        charCount = wEnd;
      }
      if (startW !== null && endW !== null) {
        ranges.push([s.words[startW].s, s.words[endW].e]);
      }
    }
  });

  // Sort and merge overlapping ranges
  ranges.sort((a, b) => a[0] - b[0]);
  const merged = [];
  for (const r of ranges) {
    if (merged.length > 0 && r[0] <= merged[merged.length - 1][1] + 0.05) {
      merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], r[1]);
    } else {
      merged.push([r[0], r[1]]);
    }
  }

  // Extend first range to 0 if starts within 5s (pre-recording noise)
  if (merged.length > 0 && merged[0][0] > 0 && merged[0][0] < 5) {
    merged[0][0] = 0;
  }

  // Align export ranges with HTML player behavior for consistent results.
  // Two adjustments:
  // 1. Range start: nudge 50ms earlier for tight gaps (ASR timestamps lag
  //    behind actual sound onset by ~30-50ms, e.g. "放" onset before ASR mark)
  // 2. Range end: snap to next kept sentence/word start (same as HTML player's
  //    seekTarget logic, prevents eating into next word like "对")
  for (let i = 0; i < merged.length; i++) {
    const s = merged[i][0], e = merged[i][1];

    // --- Range start: nudge for tight gaps ---
    if (s > 0) {
      let closestPrevEnd = 0;
      for (const sent of sentencesData) {
        if (currentDeletedSet.has(sent.idx)) continue;
        if (sent.startTime > s + 1) break;
        if (!sent.words) continue;
        for (const w of sent.words) {
          if (w.e <= s && w.e > closestPrevEnd) closestPrevEnd = w.e;
        }
      }
      const gapBefore = s - closestPrevEnd;
      // Match getSkipRanges() buffering: zero-gap word boundary needs 100ms
      // pullback to cover ASR onset lag; wider gaps need less.
      if (gapBefore < 0.02 && s > 0.10) {
        merged[i][0] = Math.max(0, s - 0.10);
      } else if (gapBefore < 0.20 && s > 0.05) {
        merged[i][0] = Math.max(0, s - 0.05);
      }
    }

    // --- Range end: align with next kept content (seekTarget logic) ---
    // Find the next kept sentence whose first word starts near range end.
    // This matches the HTML player's seekTarget behavior.
    const nextKept = sentencesData.find(ns =>
      !currentDeletedSet.has(ns.idx) && ns.startTime >= e - 0.1
    );
    if (nextKept && nextKept.startTime <= e + 0.5) {
      // Snap end to next kept sentence's start — exactly where playback resumes
      merged[i][1] = nextKept.startTime;
    }
  }

  // Convert to delete_segments.json format
  const segments = merged.map(([start, end]) => ({
    start: Math.round(start * 1000) / 1000,
    end: Math.round(end * 1000) / 1000
  }));

  // Compute stats
  const totalDeleted = segments.reduce((sum, s) => sum + (s.end - s.start), 0);
  const totalMin = Math.round(totalDeleted / 60);

  // Combined export: segments for cut_audio.py + editState for HTML restore
  const exportData = {
    segments: segments,
    editState: {
      v: 2, ts: Date.now(),
      userAdded: Array.from(userAddedDeletions),
      userRemoved: Array.from(userRemovedDeletions),
      fineEditsDisabled: Array.from(fineEditsDisabled),
      manualEdits: manualEdits.map(e => ({id: e.id, sentenceIdx: e.sentenceIdx, deleteText: e.deleteText, disabled: e.disabled})),
      manualEditCounter: manualEditCounter,
      missedCatches: missedCatches.slice(),
      speakerModifications: Object.keys(speakerModifications).length > 0 ? Object.assign({}, speakerModifications) : undefined
    }
  };

  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'delete_segments_edited.json';
  a.click();
  URL.revokeObjectURL(url);

  // Show command hint
  const cmdText = `python3 cut_audio.py 播客_精剪版.mp3 audio.mp3 delete_segments_edited.json`;
  const toast = document.createElement('div');
  toast.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1a1a2e;color:#e0e0e0;padding:24px;border-radius:12px;z-index:9999;max-width:600px;box-shadow:0 8px 32px rgba(0,0,0,0.5);font-size:14px;';
  toast.innerHTML = `
    <div style="margin-bottom:12px;font-size:16px;font-weight:bold;">&#9989; 已导出 delete_segments_edited.json</div>
    <div style="margin-bottom:8px;">${segments.length} 个删除片段，共删除约 ${totalMin} 分钟</div>
    <div style="margin-bottom:8px;">将文件放到分析目录，运行：</div>
    <div style="background:#0d1117;padding:12px;border-radius:8px;font-family:monospace;font-size:13px;word-break:break-all;cursor:pointer;" onclick="navigator.clipboard.writeText('${cmdText}');this.style.background='#1a3a1a';" title="点击复制">${cmdText}</div>
    <div style="margin-top:8px;color:#888;font-size:12px;">点击命令可复制到剪贴板</div>
    <button onclick="this.parentElement.remove()" style="margin-top:12px;padding:6px 16px;background:#333;color:#fff;border:none;border-radius:6px;cursor:pointer;">关闭</button>
  `;
  document.body.appendChild(toast);
}

// ===== FILTERS =====
function setFilter(f) {
  currentFilter = f;
  document.querySelectorAll('.filter-inner .filter-btn').forEach(btn => {
    if (!btn.dataset.type && btn.textContent.includes('全部') && f === 'all') btn.className = 'filter-btn active';
    else if (!btn.dataset.type && btn.textContent.includes('仅删除') && f === 'deleted') btn.className = 'filter-btn active-red';
    else if (!btn.dataset.type && btn.textContent.includes('仅保留') && f === 'kept') btn.className = 'filter-btn active';
    else if (!btn.dataset.type) btn.className = 'filter-btn';
  });
  applyFilters();
}

function setTypeFilter(t) {
  currentTypeFilter = t;
  document.querySelectorAll('.filter-inner .filter-btn[data-type]').forEach(btn => {
    btn.className = btn.dataset.type === t ? 'filter-btn active' : 'filter-btn';
  });
  applyFilters();
}

function searchText(query) {
  searchQuery = query.toLowerCase();
  applyFilters();
}

function applyFilters() {
  sentencesData.forEach(s => {
    const row = document.getElementById('row-' + s.idx);
    if (!row) return;

    let visible = true;
    const isDeleted = currentDeletedSet.has(s.idx);

    // Show/hide filter
    if (currentFilter === 'deleted' && !isDeleted) visible = false;
    if (currentFilter === 'kept' && isDeleted) visible = false;

    // Type filter
    if (currentTypeFilter !== 'all') {
      if (!isDeleted || s.deleteType !== currentTypeFilter) {
        // Also hide if it's user-added deletion (no type)
        if (!(isDeleted && userAddedDeletions.has(s.idx))) {
          visible = false;
        }
      }
    }

    // Search filter
    if (searchQuery && !s.text.toLowerCase().includes(searchQuery) && !s.speaker.toLowerCase().includes(searchQuery)) {
      visible = false;
    }

    row.classList.toggle('hidden', !visible);
  });

  // Also show/hide block bars
  document.querySelectorAll('.block-bar').forEach(bar => {
    const blockId = parseInt(bar.dataset.blockId);
    const block = blocksData.find(b => b.id === blockId);
    if (!block) return;

    let visible = true;
    if (currentFilter === 'kept') visible = false;
    if (currentTypeFilter !== 'all' && block.type !== currentTypeFilter) visible = false;

    bar.classList.toggle('hidden', !visible);
  });
}

// ===== HIGHLIGHT ROW =====
function highlightRow(idx) {
  // Don't fire if user is selecting text (drag selection)
  const sel = window.getSelection();
  if (sel && !sel.isCollapsed) return;

  // If row is deleted, click to restore it
  if (currentDeletedSet.has(idx)) {
    toggleDeletion(idx);
    return;
  }

  // Remove previous highlight
  if (highlightedIdx >= 0) {
    const prev = document.getElementById('row-' + highlightedIdx);
    if (prev) prev.classList.remove('highlight');
  }
  highlightedIdx = idx;
  const row = document.getElementById('row-' + idx);
  if (row) row.classList.add('highlight');

  // Jump audio to this sentence
  const s = sentencesData.find(s => s.idx === idx);
  if (s && s.startTime !== undefined) {
    const audio = document.getElementById('audio-original');
    audio.currentTime = s.startTime;
  }
}


// ===== MANUAL TEXT EDITS =====
// manualEdits: array of {sentenceIdx, deleteText, id}
const manualEdits = [];
let manualEditCounter = 0;
// speakerModifications: {sentenceIdx: newSpeaker}
const speakerModifications = {};
// missedCatches: user-reported AI misses
const missedCatches = [];
let missedCatchCounter = 0;
let _mcPendingText = '';
let _mcPendingSentenceIdx = -1;
let _mcPendingBatchIndices = null;
// comments: user annotations (not deletions)
const comments = [];
let commentCounter = 0;
// restoreFeedback: reasons for restoring deletions
const restoreFeedback = [];
let restoreFeedbackCounter = 0;

// Listen for text selection
document.addEventListener('mouseup', function(e) {
  const toolbar = document.getElementById('selection-toolbar');
  const sel = window.getSelection();
  
  if (!sel || sel.isCollapsed || sel.toString().trim().length === 0) {
    toolbar.classList.remove('visible');
    return;
  }
  
  // Check if selection is within a sentence text element
  const anchor = sel.anchorNode;
  const focus = sel.focusNode;
  if (!anchor || !focus) { toolbar.classList.remove('visible'); return; }
  
  const textEl = anchor.parentElement.closest('.s-text');
  if (!textEl) { toolbar.classList.remove('visible'); return; }
  
  const focusTextEl = focus.parentElement.closest('.s-text');
  if (textEl !== focusTextEl) { toolbar.classList.remove('visible'); return; }
  
  // Allow selection across fine-delete spans (user may want to select entire sentence).
  // Only block if selection is entirely within a manual-delete span (already handled).
  const anchorInManual = anchor.parentElement.closest('.manual-delete');
  const focusInManual = focus.parentElement.closest('.manual-delete');
  if (anchorInManual && focusInManual && anchorInManual === focusInManual) {
    toolbar.classList.remove('visible');
    return;
  }
  
  // Get selected text, stripping UI-only labels (tag names like "stutter", "手动")
  const range = sel.getRangeAt(0);
  const frag = range.cloneContents();
  frag.querySelectorAll('.fine-tag, .manual-tag, .silence-pause, .incoming-silence').forEach(el => el.remove());
  const selectedText = (frag.textContent || '').trim();
  if (selectedText.length === 0) { toolbar.classList.remove('visible'); return; }

  // Show toolbar near selection
  const rect = range.getBoundingClientRect();
  toolbar.style.left = Math.min(rect.left, window.innerWidth - 220) + 'px';
  toolbar.style.top = (rect.top - 40) + 'px';
  document.getElementById('sel-preview').textContent = '"' + (selectedText.length > 20 ? selectedText.slice(0,20) + '...' : selectedText) + '"';
  toolbar.classList.add('visible');
});

// Hide toolbar on click elsewhere
document.addEventListener('mousedown', function(e) {
  if (!e.target.closest('#selection-toolbar')) {
    // Don't hide immediately - let mouseup handler decide
    setTimeout(() => {
      const sel = window.getSelection();
      if (!sel || sel.isCollapsed) {
        document.getElementById('selection-toolbar').classList.remove('visible');
      }
    }, 200);
  }
});

function markSelectionDeleted() {
  const sel = window.getSelection();
  if (!sel || sel.isCollapsed) return;

  // Extract selected text, excluding fine-tag/silence-pause labels
  // (these are UI elements, not part of the sentence text)
  const range = sel.getRangeAt(0);
  const fragment = range.cloneContents();
  // Remove tag labels that aren't part of actual sentence text
  fragment.querySelectorAll('.fine-tag, .manual-tag, .silence-pause, .incoming-silence').forEach(el => el.remove());
  const selectedText = (fragment.textContent || '').trim();
  if (!selectedText) return;

  // Find which sentence this is in
  const anchor = sel.anchorNode;
  const textEl = anchor.parentElement.closest('.s-text');
  if (!textEl) return;

  const row = textEl.closest('[id^="row-"]');
  if (!row) return;
  const sentenceIdx = parseInt(row.id.replace('row-', ''));

  // Create manual edit
  const editId = ++manualEditCounter;
  const edit = { id: editId, sentenceIdx: sentenceIdx, deleteText: selectedText };
  manualEdits.push(edit);
  
  // Push undo
  undoStack.push({ type: 'manualEdit', editId: editId });
  
  // Clear selection
  sel.removeAllRanges();
  document.getElementById('selection-toolbar').classList.remove('visible');
  
  invalidateSkipRanges();
  // Re-render the sentence
  rebuildRowWithManualEdits(sentenceIdx);
  updateStats();
}

function toggleManualEdit(editId) {
  const edit = manualEdits.find(e => e.id === editId);
  if (!edit) return;

  const wasDisabled = !!edit.disabled;
  undoStack.push({ type: 'manualEditToggle', editId: editId, wasDisabled: wasDisabled });

  edit.disabled = !edit.disabled;
  invalidateSkipRanges();
  rebuildRowWithManualEdits(edit.sentenceIdx);
  updateStats();

  // Show restore feedback when disabling a manual edit (= restoring)
  if (!wasDisabled) {
    showRestorePanel({
      editType: 'manual',
      sentenceIdx: edit.sentenceIdx,
      text: edit.deleteText || ''
    });
  }
}

function rebuildRowWithManualEdits(sentenceIdx) {
  const s = sentencesData.find(s => s.idx === sentenceIdx);
  if (!s) return;
  const row = document.getElementById('row-' + sentenceIdx);
  if (!row) return;
  const textEl = row.querySelector('.s-text');
  if (!textEl) return;
  
  // Start with the sentence text
  let fullText = s.text;
  
  // Collect all active deletions (fine edits + manual edits) as ranges
  const deletions = [];
  
  // AI fine edit (use charOffset for precision, fallback to indexOf)
  if (s.fineEdit && s.fineEdit.deleteText && !fineEditsDisabled.has(s.fineEdit.idx)) {
    const pos = (s.fineEdit.charOffset !== undefined) ? s.fineEdit.charOffset : fullText.indexOf(s.fineEdit.deleteText);
    if (pos >= 0) {
      deletions.push({
        start: pos,
        end: pos + s.fineEdit.deleteText.length,
        type: 'fine',
        feIdx: s.fineEdit.idx,
        label: s.fineEdit.type,
        reason: s.fineEdit.reason
      });
    }
  }
  
  // Manual edits for this sentence
  const sentManual = manualEdits.filter(e => e.sentenceIdx === sentenceIdx);
  for (const me of sentManual) {
    // Use charOffset for precise matching, fallback to indexOf
    let pos = -1;
    if (me.charOffset !== undefined && fullText.substring(me.charOffset, me.charOffset + me.deleteText.length) === me.deleteText) {
      pos = me.charOffset;
    } else {
      pos = fullText.indexOf(me.deleteText);
    }
    if (pos >= 0) {
      deletions.push({
        start: pos,
        end: pos + me.deleteText.length,
        type: 'manual',
        editId: me.id,
        disabled: !!me.disabled
      });
    }
  }

  // Fast path: if any manual edit covers the entire sentence, just use it directly
  // (avoids complex overlap resolution that can lose segments)
  const fullCoverEdit = deletions.find(d => d.type === 'manual' && !d.disabled && d.start === 0 && d.end >= fullText.length);
  if (fullCoverEdit) {
    let html = '';
    if (s.fineEdit) {
      const feDisabled = fineEditsDisabled.has(s.fineEdit.idx);
      if (s.fineEdit.type !== 'silence') {
        const feClass = feDisabled ? 'fine-tag disabled' : 'fine-tag';
        html += '<span class="' + feClass + '" data-fine-idx="' + s.fineEdit.idx + '" onclick="event.stopPropagation(); toggleFineEdit(' + s.fineEdit.idx + ')" title="' + escapeHtml(s.fineEdit.reason || '') + '">' + escapeHtml(s.fineEdit.type) + '</span>';
      }
    }
    for (const me of sentManual) {
      const tagClass = me.disabled ? 'manual-tag disabled' : 'manual-tag';
      html += '<span class="' + tagClass + '">手动</span>';
    }
    html += '<span class="manual-delete" onclick="event.stopPropagation(); toggleManualEdit(' + fullCoverEdit.editId + ')" title="手动删除 - 点击恢复">' + escapeHtml(fullText) + '</span>';
    textEl.innerHTML = html;
    return;
  }

  // Sort deletions by position, then flatten overlaps into non-overlapping segments.
  // When a manual edit overlaps a fine edit, split into segments:
  //   [fine-only] [overlap → manual wins] [manual-only]
  deletions.sort((a, b) => a.start - b.start);
  const segments = [];
  for (const d of deletions) {
    if (segments.length === 0) { segments.push({...d}); continue; }
    const last = segments[segments.length - 1];
    if (d.start >= last.end) {
      // No overlap
      segments.push({...d});
    } else {
      // Overlap: split into non-overlapping parts
      // Part before overlap belongs to 'last', overlap region uses higher-priority type
      const overlapStart = d.start;
      const overlapEnd = Math.min(last.end, d.end);
      // Manual type takes priority over fine
      const winnerType = (d.type === 'manual' || last.type === 'manual') ? 'manual' : last.type;
      const winnerId = d.type === 'manual' ? d.editId : (last.type === 'manual' ? last.editId : d.feIdx || last.feIdx);
      const winnerDisabled = d.type === 'manual' ? d.disabled : (last.type === 'manual' ? last.disabled : false);

      if (overlapStart > last.start) {
        // Trim 'last' to before overlap
        const before = {...last, end: overlapStart};
        // Replace last with trimmed version + overlap segment
        segments[segments.length - 1] = before;
        segments.push({ start: overlapStart, end: overlapEnd, type: winnerType, editId: winnerId, feIdx: winnerId, disabled: winnerDisabled });
      } else {
        // Overlap starts at same position — just change type of existing segment
        segments[segments.length - 1] = { ...last, end: overlapEnd, type: winnerType, editId: winnerId, feIdx: winnerId, disabled: winnerDisabled };
      }
      // Remainder after overlap
      if (d.end > last.end) {
        segments.push({ start: last.end, end: d.end, type: d.type, editId: d.editId, feIdx: d.feIdx, disabled: d.disabled });
      } else if (last.end > overlapEnd) {
        segments.push({ start: overlapEnd, end: last.end, type: last.type, editId: last.editId, feIdx: last.feIdx, disabled: last.disabled });
      }
    }
  }

  // Build HTML
  let html = '';

  // Add fine edit tag if present (silence tag saved for after text)
  let silenceSuffix = '';
  if (s.fineEdit) {
    const feDisabled = fineEditsDisabled.has(s.fineEdit.idx);
    if (s.fineEdit.type === 'silence') {
      const dur = (s.fineEdit.de || 0) - (s.fineEdit.ds || 0);
      const deleteDur = Math.max(0, dur - 0.8);
      const pauseClass = feDisabled ? 'silence-pause disabled' : 'silence-pause';
      silenceSuffix = ' <span class="' + pauseClass + '" data-fine-idx="' + s.fineEdit.idx + '" onclick="event.stopPropagation(); toggleFineEdit(' + s.fineEdit.idx + ')" title="静音' + dur.toFixed(1) + 's → 保留0.8s，删' + deleteDur.toFixed(1) + 's — 点击切换">-' + deleteDur.toFixed(1) + 's</span>';
    } else {
      const feClass = feDisabled ? 'fine-tag disabled' : 'fine-tag';
      html += '<span class="' + feClass + '" data-fine-idx="' + s.fineEdit.idx + '" onclick="event.stopPropagation(); toggleFineEdit(' + s.fineEdit.idx + ')" title="' + escapeHtml(s.fineEdit.reason || '') + '">' + escapeHtml(s.fineEdit.type) + '</span>';
    }
  }

  // Add manual edit tags
  for (const me of sentManual) {
    const tagClass = me.disabled ? 'manual-tag disabled' : 'manual-tag';
    html += '<span class="' + tagClass + '" onclick="event.stopPropagation(); toggleManualEdit(' + me.id + ')" title="手动标记删除">手动</span>';
  }

  // Render text with deletion segments (guaranteed non-overlapping)
  let lastEnd = 0;
  for (const d of segments) {
    if (d.start < lastEnd) continue; // safety: skip if somehow still overlapping
    html += escapeHtml(fullText.substring(lastEnd, d.start));
    const escDel = escapeHtml(fullText.substring(d.start, d.end));

    if (d.type === 'fine') {
      html += '<span class="fine-delete" onclick="event.stopPropagation(); toggleFineEdit(' + d.feIdx + ')" title="点击切换保留/删除">' + escDel + '</span>';
    } else if (d.type === 'manual') {
      if (d.disabled) {
        html += '<span class="manual-restored" onclick="event.stopPropagation(); toggleManualEdit(' + d.editId + ')" title="已恢复 - 点击重新删除" style="cursor:pointer;text-decoration-style:dotted;text-decoration-line:underline;text-decoration-color:#d97706;">' + escDel + '</span>';
      } else {
        html += '<span class="manual-delete" onclick="event.stopPropagation(); toggleManualEdit(' + d.editId + ')" title="手动删除 - 点击恢复">' + escDel + '</span>';
      }
    }
    lastEnd = d.end;
  }
  html += escapeHtml(fullText.substring(lastEnd));
  html += silenceSuffix;

  textEl.innerHTML = html;
}

// ===== AUDIO PLAYER (with dynamic cut mode) =====
const speeds = [1, 1.25, 1.5, 2, 0.75];
const currentSpeed = { original: 0, cut: 0 };
let cutMode = false;
let _skipRangesCache = null;
let _skipRangesDirty = true;


// Mark skip ranges dirty whenever edits change
function invalidateSkipRanges() { _skipRangesDirty = true; }

// Compute delete time ranges from current edit state
function getSkipRanges() {
  if (!_skipRangesDirty && _skipRangesCache) return _skipRangesCache;

  const ranges = [];

  sentencesData.forEach(s => {
    // Sentence-level deletions
    if (currentDeletedSet.has(s.idx)) {
      ranges.push([s.startTime, s.endTime]);
      return; // Whole sentence deleted, skip fine/manual edits
    }

    // Fine edits (word-level or whole-sentence)
    if (s.fineEdit && !fineEditsDisabled.has(s.fineEdit.idx)) {
      const fe = s.fineEdit;
      if (fe.wholeSentence) {
        ranges.push([s.startTime, s.endTime]);
      } else if (fe.type === 'silence' && fe.ds !== undefined && fe.de !== undefined) {
        // Silence: keep 0.8s natural pause, only delete excess
        const silKeep = 0.8;
        if (fe.de - fe.ds > silKeep) {
          ranges.push([fe.ds + silKeep, fe.de, 0, 'sil']);
        }
      } else if (fe.ds !== undefined && fe.de !== undefined) {
        ranges.push([fe.ds, fe.de]);
      }
    }

    // Extra fine edits (multiple stutters in same sentence)
    if (s.extraFineEdits) {
      for (const efe of s.extraFineEdits) {
        if (!fineEditsDisabled.has(efe.idx) && efe.ds !== undefined && efe.de !== undefined) {
          ranges.push([efe.ds, efe.de]);
        }
      }
    }

    // Extra silences (silence edits when primary edit is a text edit)
    if (s.extraSilences) {
      for (const es of s.extraSilences) {
        if (!fineEditsDisabled.has(es.idx) && es.ds !== undefined && es.de !== undefined) {
          // Silence: keep 0.8s, only delete excess
          const silKeep = 0.8;
          if (es.de - es.ds > silKeep) {
            ranges.push([es.ds + silKeep, es.de, 0, 'sil']);
          }
        }
      }
    }

    // Manual edits (word-level)
    const sentManual = manualEdits.filter(e => e.sentenceIdx === s.idx && !e.disabled);
    for (const me of sentManual) {
      if (!s.words || s.words.length === 0) continue;
      const wordTexts = s.words.map(w => w.t);
      const fullText = wordTexts.join('');
      const pos = fullText.indexOf(me.deleteText);
      if (pos < 0) continue;
      
      let charCount = 0, startW = null, endW = null;
      for (let i = 0; i < wordTexts.length; i++) {
        const wEnd = charCount + wordTexts[i].length;
        if (startW === null && wEnd > pos) startW = i;
        if (wEnd >= pos + me.deleteText.length) { endW = i; break; }
        charCount = wEnd;
      }
      if (startW !== null && endW !== null) {
        ranges.push([s.words[startW].s, s.words[endW].e]);
      }
    }
  });
  
  // Sort and merge overlapping ranges
  ranges.sort((a, b) => a[0] - b[0]);
  const merged = [];
  for (const r of ranges) {
    if (merged.length > 0 && r[0] <= merged[merged.length - 1][1] + 0.05) {
      merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], r[1]);
    } else {
      merged.push([...r]);
    }
  }

  // Extend first range to 0 if it starts within 5s (pre-recording noise)
  if (merged.length > 0 && merged[0][0] > 0 && merged[0][0] < 5) {
    merged[0][0] = 0;
  }

  // Compute adaptive lookahead for each range: [start, end, lookahead]
  // Based on gap to closest preceding kept word. Sentence gaps are large (~1s),
  // fine edit gaps are tiny (~0ms). Lookahead capped at 50ms-300ms.
  // For tight gaps (< 100ms), also nudge range start earlier by 50ms so that
  // even with JS timer jitter (~50ms), deleted content can't leak through.
  for (let i = 0; i < merged.length; i++) {
    const s = merged[i][0];
    let closestPrevEnd = 0;
    for (const sent of sentencesData) {
      if (currentDeletedSet.has(sent.idx)) continue;
      if (sent.startTime > s + 1) break;
      if (!sent.words) continue;
      for (const w of sent.words) {
        if (w.e <= s && w.e > closestPrevEnd) closestPrevEnd = w.e;
      }
    }
    const gap = s - closestPrevEnd;
    // For tight gaps: extend range start back for safety buffer
    // JS timer jitter is ~50-80ms; for zero-gap fine edits (stutter at word
    // boundary), we need more aggressive buffering to prevent onset leaking.
    if (gap < 0.02 && merged[i][0] > 0.10) {
      // Zero gap (word boundary): pull back 100ms — the previous word's
      // tail consonant is usually done by then
      merged[i][0] = Math.max(0, merged[i][0] - 0.10);
    } else if (gap < 0.10 && merged[i][0] > 0.05) {
      merged[i][0] = Math.max(0, merged[i][0] - 0.05);
    }
    const adjustedGap = merged[i][0] - closestPrevEnd;
    merged[i][2] = Math.min(0.30, Math.max(0.05, adjustedGap));
  }

  _skipRangesCache = merged;
  _skipRangesDirty = false;
  return merged;
}

// Convert original time → virtual cut time
function originalToVirtual(t) {
  const ranges = getSkipRanges();
  let skipped = 0;
  for (const [s, e] of ranges) {
    if (e <= t) skipped += e - s;
    else if (s < t) { skipped += t - s; break; }
    else break;
  }
  return t - skipped;
}

// Convert virtual cut time → original time
function virtualToOriginal(vt) {
  const ranges = getSkipRanges();
  let accumulated = 0;
  let origTime = vt;
  
  for (const [s, e] of ranges) {
    if (s <= origTime + accumulated) {
      accumulated += e - s;
      origTime = vt + accumulated;
    } else {
      break;
    }
  }
  return origTime;
}

// Total virtual duration
function getVirtualDuration() {
  const audio = document.getElementById('audio-original');
  if (!audio || !audio.duration) return 0;
  const ranges = getSkipRanges();
  let totalSkip = 0;
  for (const [s, e] of ranges) totalSkip += e - s;
  return audio.duration - totalSkip;
}

function togglePlay(which) {
  const audio = document.getElementById('audio-original');
  const btn = document.querySelector('#player-' + which + ' .play-btn');

  // Stop the other player
  const other = which === 'original' ? 'cut' : 'original';
  const otherBtn = document.querySelector('#player-' + other + ' .play-btn');
  
  if (which === 'cut') {
    // If original was playing, stop it
    if (!cutMode && !audio.paused) {
      audio.pause();
    }
    const origBtn = document.querySelector('#player-original .play-btn');
    origBtn.classList.remove('playing');
    origBtn.innerHTML = '&#9654;';
    
    cutMode = true;
    if (audio.paused) {
      // Seek past any current skip range, wait for seek to complete, then play
      const ranges = getSkipRanges();
      const t = audio.currentTime;
      let needSeek = false;
      for (const [s, e] of ranges) {
        if (t >= s - 0.01 && t < e) {
          let seekTarget = e;
          const nextKept = sentencesData.find(ns => !currentDeletedSet.has(ns.idx) && ns.startTime >= e - 0.1);
          if (nextKept && nextKept.startTime <= e + 0.5) seekTarget = nextKept.startTime;
          audio.currentTime = seekTarget;
          needSeek = true;
          break;
        }
      }
      if (needSeek) {
        audio.addEventListener('seeked', function onReady() {
          audio.removeEventListener('seeked', onReady);
          audio.play();
          scheduleNextSkip();
        }, { once: true });
      } else {
        audio.play();
        scheduleNextSkip();
      }
      btn.classList.add('playing');
      btn.innerHTML = '&#10074;&#10074;';
    } else {
      audio.pause();
      btn.classList.remove('playing');
      btn.innerHTML = '&#9654;';
    }
  } else {
    // Original mode
    const cutBtn = document.querySelector('#player-cut .play-btn');
    cutBtn.classList.remove('playing');
    cutBtn.innerHTML = '&#9654;';
    
    if (_skipScheduled) { clearTimeout(_skipScheduled); _skipScheduled = null; }
    cutMode = false;
    if (audio.paused) {
      audio.play();
      btn.classList.add('playing');
      btn.innerHTML = '&#10074;&#10074;';
    } else {
      audio.pause();
      btn.classList.remove('playing');
      btn.innerHTML = '&#9654;';
    }
  }
}

let _skipScheduled = null;
let _lastSkipTime = 0;

function skipIfNeeded() {
  const audio = document.getElementById('audio-original');
  if (!cutMode || audio.paused) return;

  // Debounce: prevent rapid consecutive skips causing stutter
  const now = performance.now();
  if (now - _lastSkipTime < 150) {
    // Still cooling down from last skip - reschedule
    setTimeout(() => skipIfNeeded(), 150 - (now - _lastSkipTime));
    return;
  }

  const t = audio.currentTime;
  const rate = audio.playbackRate || 1;
  const ranges = getSkipRanges();

  for (const r of ranges) {
    const s = r[0], e = r[1], la = r[2] || 0.30;
    // Already inside or approaching a delete range (adaptive lookahead)
    if (t >= s - la * rate && t < e) {
      // Find next kept sentence's startTime for clean landing
      // Only use nextKept if it's close to range end (< 0.5s), otherwise
      // we're mid-sentence (fine edit) and should stay at range end
      let seekTarget = e;
      const nextKept = sentencesData.find(ns => !currentDeletedSet.has(ns.idx) && ns.startTime >= e - 0.1);
      if (nextKept && nextKept.startTime <= e + 0.5) seekTarget = nextKept.startTime;

      // If seekTarget lands inside another skip range, jump past it too (merge)
      for (const r2 of ranges) {
        if (seekTarget >= r2[0] && seekTarget < r2[1]) {
          seekTarget = r2[1];
        }
      }

      // Add 30ms offset for tight-gap edits (stutter at word boundary) to skip
      // past word onset transient. Skip offset for silence ranges where the
      // natural gap provides buffer — adding offset would clip the next word.
      if (r[3] !== 'sil') seekTarget += 0.03;

      _lastSkipTime = performance.now();
      const isSilenceSkip = r[3] === 'sil';

      if (isSilenceSkip) {
        // Silence skip: current playback is in silence, no audio to click/pop.
        // Seek immediately and restore volume without delay — prevents clipping
        // the first word after the silence.
        audio.currentTime = seekTarget;
        scheduleNextSkip();
      } else {
        // Speech skip: fade-out(10ms) → seek → settle(40ms) → fade-in(50ms)
        // The fade-out prevents click/pop when muting mid-word (e.g., safety buffer
        // pulls skip start into a preceding word at a zero-gap boundary).
        const savedVol = audio.volume;
        audio.volume = savedVol * 0.3;
        setTimeout(() => {
          audio.volume = 0;
          audio.currentTime = seekTarget;

          // Restore volume after seek completes
          let resumed = false;
          const resume = () => {
            if (resumed) return;
            resumed = true;
            // Hold mute for 40ms (decoder settling), then 4-step fade-in over 50ms
            audio.volume = 0;
            setTimeout(() => {
              audio.volume = savedVol * 0.15;
              setTimeout(() => { audio.volume = savedVol * 0.4; }, 12);
              setTimeout(() => { audio.volume = savedVol * 0.7; }, 25);
              setTimeout(() => { audio.volume = savedVol; }, 50);
            }, 40);
            if (cutMode && audio.paused) audio.play();
            scheduleNextSkip();
          };
          audio.addEventListener('seeked', resume, { once: true });
          setTimeout(resume, 80); // fallback if seeked doesn't fire
        }, 10);
      }
      return;
    }
  }

  // Not in a skip range - schedule the next one for precise timing
  scheduleNextSkip();
}

function scheduleNextSkip() {
  const audio = document.getElementById('audio-original');
  if (!cutMode || audio.paused) { _skipScheduled = null; return; }
  
  if (_skipScheduled) clearTimeout(_skipScheduled);
  
  const t = audio.currentTime;
  const rate = audio.playbackRate || 1;
  const ranges = getSkipRanges();
  
  // Find the next skip range ahead of us
  for (const r of ranges) {
    const s = r[0], la = r[2] || 0.30;
    if (s > t) {
      // Schedule skip with adaptive lookahead before the range starts
      const delay = Math.max(0, ((s - t) / rate - la) * 1000);
      _skipScheduled = setTimeout(() => {
        _skipScheduled = null;
        skipIfNeeded();
      }, delay);
      return;
    }
  }
  _skipScheduled = null;
}

function cycleSpeed(which) {
  const audio = document.getElementById('audio-original');
  const btn = document.querySelector('#player-' + which + ' .speed-btn');
  currentSpeed[which] = (currentSpeed[which] + 1) % speeds.length;
  audio.playbackRate = speeds[currentSpeed[which]];
  btn.textContent = speeds[currentSpeed[which]] + 'x';
}

function seekAudio(event, which) {
  const audio = document.getElementById('audio-original');
  const bar = event.currentTarget;
  const rect = bar.getBoundingClientRect();
  const pct = (event.clientX - rect.left) / rect.width;
  
  if (which === 'cut') {
    cutMode = true;
    const vDur = getVirtualDuration();
    const vTime = pct * vDur;
    audio.currentTime = virtualToOriginal(vTime);
  } else {
    cutMode = false;
    audio.currentTime = pct * audio.duration;
  }
}

function seekToTime(seconds) {
  const audio = document.getElementById('audio-original');
  audio.currentTime = seconds;
  if (audio.paused) {
    togglePlay('original');
  }
}

function formatTime(s) {
  s = Math.floor(s);
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = s % 60;
  if (h > 0) return h + ':' + String(m).padStart(2,'0') + ':' + String(sec).padStart(2,'0');
  return m + ':' + String(sec).padStart(2,'0');
}

function updateProgress() {
  const audio = document.getElementById('audio-original');
  
  if (audio && audio.duration) {
    // Skip logic for cut mode
    if (cutMode && !audio.paused) {
      const _t = audio.currentTime;
      skipIfNeeded();
    }
    
    // Original player progress
    const fillOrig = document.getElementById('progress-original');
    const timeOrig = document.getElementById('time-original');
    const pctOrig = (audio.currentTime / audio.duration) * 100;
    fillOrig.style.width = pctOrig + '%';
    timeOrig.textContent = formatTime(audio.currentTime) + ' / ' + formatTime(audio.duration);
    
    // Cut player progress (virtual time)
    const fillCut = document.getElementById('progress-cut');
    const timeCut = document.getElementById('time-cut');
    const vDur = getVirtualDuration();
    const vTime = originalToVirtual(audio.currentTime);
    const pctCut = vDur > 0 ? (vTime / vDur) * 100 : 0;
    fillCut.style.width = pctCut + '%';
    timeCut.textContent = formatTime(vTime) + ' / ' + formatTime(vDur);
  }
  
  requestAnimationFrame(updateProgress);
}

// ===== KEYBOARD SHORTCUTS =====
document.addEventListener('keydown', function(e) {
  // D key to toggle deletion on highlighted row
  if (e.key === 'd' || e.key === 'D') {
    if (e.target.tagName === 'INPUT') return; // Don't trigger in search box
    if (highlightedIdx >= 0) {
      toggleDeletion(highlightedIdx);
    }
  }

  // Ctrl+Z to undo
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
    if (e.target.tagName === 'INPUT') return;
    e.preventDefault();
    undo();
  }

  // Arrow keys to navigate rows
  if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
    if (e.target.tagName === 'INPUT') return;
    e.preventDefault();
    const visibleRows = sentencesData.filter(s => {
      const row = document.getElementById('row-' + s.idx);
      return row && !row.classList.contains('hidden');
    });
    if (visibleRows.length === 0) return;

    let currentPos = visibleRows.findIndex(s => s.idx === highlightedIdx);
    if (e.key === 'ArrowDown') {
      currentPos = Math.min(currentPos + 1, visibleRows.length - 1);
    } else {
      currentPos = Math.max(currentPos - 1, 0);
    }
    if (currentPos < 0) currentPos = 0;
    highlightRow(visibleRows[currentPos].idx);
    const row = document.getElementById('row-' + visibleRows[currentPos].idx);
    if (row) row.scrollIntoView({ block: 'center', behavior: 'smooth' });
  }
});

// ===== SCROLL TO TOP BUTTON =====
window.addEventListener('scroll', function() {
  const btn = document.getElementById('scroll-top');
  btn.classList.toggle('visible', window.scrollY > 400);
});

// ===== INIT =====
// Populate stat cards dynamically
document.getElementById('stat-total').textContent = TOTAL_SENTENCES;
document.getElementById('stat-ai-deleted').textContent = AI_DELETED_COUNT - AI_SUGGESTED_COUNT;
document.getElementById('stat-ai-suggested').textContent = AI_SUGGESTED_COUNT;
document.getElementById('stat-ai-kept').textContent = TOTAL_SENTENCES - AI_DELETED_COUNT;
document.getElementById('stat-fine-edits').textContent = sentencesData.filter(s => s.fineEdit).length;
document.getElementById('stat-blocks').textContent = blocksData.length;
document.getElementById('stat-final-delete').textContent = currentDeletedSet.size;

buildSummaryTable();
buildTranscript();
restoreState();
buildSpeakerPanel();
requestAnimationFrame(updateProgress);

// Pre-seek audio to first non-deleted sentence so cut-mode playback starts clean
const _initAudio = document.getElementById('audio-original');
_initAudio.addEventListener('loadedmetadata', function() {
  const firstKept = sentencesData.find(s => !currentDeletedSet.has(s.idx));
  if (firstKept) {
    _initAudio.currentTime = firstKept.startTime;
  }
}, { once: true });

// ===== MISSED CATCH FEEDBACK =====

const mcTypeLabels = {
  in_sentence_repeat: '句内重复',
  repeated_sentence: '重复句',
  stutter: '卡顿词',
  self_correction: '重说纠正',
  consecutive_filler: '连续填充词',
  residual_sentence: '残句',
  silence: '长静音',
  production_talk: '录制讨论',
  chit_chat: '闲聊',
  other: '其他'
};

function markSelectionDeletedAndPrompt() {
  const sel = window.getSelection();
  if (!sel || sel.isCollapsed) return;

  // Strip UI-only labels from selection (same as markSelectionDeleted)
  const range = sel.getRangeAt(0);
  const fragment = range.cloneContents();
  fragment.querySelectorAll('.fine-tag, .manual-tag, .silence-pause, .incoming-silence, .missed-catch-tag').forEach(el => el.remove());
  const selectedText = (fragment.textContent || '').trim();
  if (!selectedText) return;

  const anchor = sel.anchorNode;
  const textEl = anchor.parentElement.closest('.s-text');
  if (!textEl) return;
  const row = textEl.closest('[id^="row-"]');
  if (!row) return;
  const sentenceIdx = parseInt(row.id.replace('row-', ''));

  // Calculate charOffset: count text from s-text start to selection start,
  // excluding UI tags, to get exact position in raw sentence text.
  let charOffset;
  try {
    const preRange = document.createRange();
    preRange.setStart(textEl, 0);
    preRange.setEnd(range.startContainer, range.startOffset);
    const preFrag = preRange.cloneContents();
    preFrag.querySelectorAll('.fine-tag, .manual-tag, .silence-pause, .incoming-silence, .missed-catch-tag').forEach(el => el.remove());
    charOffset = (preFrag.textContent || '').length;
  } catch(e) { charOffset = undefined; }

  // 1) Do the deletion immediately (same as markSelectionDeleted)
  const editId = ++manualEditCounter;
  const edit = { id: editId, sentenceIdx: sentenceIdx, deleteText: selectedText, charOffset: charOffset };
  manualEdits.push(edit);
  undoStack.push({ type: 'manualEdit', editId: editId });
  sel.removeAllRanges();
  document.getElementById('selection-toolbar').classList.remove('visible');
  invalidateSkipRanges();
  rebuildRowWithManualEdits(sentenceIdx);
  updateStats();

  // 2) Remember pending info for feedback panel
  _mcPendingText = selectedText;
  _mcPendingSentenceIdx = sentenceIdx;
  _mcPendingBatchIndices = null;

  // 3) Show feedback panel near the deleted text
  const panel = document.getElementById('missed-catch-panel');
  document.getElementById('mc-preview-text').textContent = selectedText.length > 80 ? selectedText.slice(0, 80) + '...' : selectedText;
  document.getElementById('mc-reason').value = '';

  const rowRect = row.getBoundingClientRect();
  panel.style.left = Math.min(rowRect.left + 40, window.innerWidth - 340) + 'px';
  panel.style.top = (rowRect.bottom + 4) + 'px';
  panel.classList.add('visible');

  setTimeout(() => document.getElementById('mc-type').focus(), 100);
}

function hideMissedCatchPanel() {
  document.getElementById('missed-catch-panel').classList.remove('visible');
  _mcPendingText = '';
  _mcPendingSentenceIdx = -1;
  _mcPendingBatchIndices = null;
}

// Enter key in reason input confirms
document.addEventListener('keydown', function(e) {
  if (e.key === 'Enter' && document.getElementById('missed-catch-panel').classList.contains('visible')) {
    e.preventDefault();
    confirmMissedCatch();
  }
  if (e.key === 'Escape' && document.getElementById('missed-catch-panel').classList.contains('visible')) {
    e.preventDefault();
    hideMissedCatchPanel();
  }
});

function confirmMissedCatch() {
  if (!_mcPendingText || _mcPendingSentenceIdx < 0) return;

  const mcType = document.getElementById('mc-type').value;
  const reason = document.getElementById('mc-reason').value.trim();
  const id = ++missedCatchCounter;

  const sent = sentencesData.find(s => s.idx === _mcPendingSentenceIdx);
  let tsStart = null, tsEnd = null;

  if (_mcPendingBatchIndices && _mcPendingBatchIndices.length > 1) {
    // Batch deletion: timestamp from first to last sentence
    const firstSent = sentencesData.find(s => s.idx === _mcPendingBatchIndices[0]);
    const lastSent = sentencesData.find(s => s.idx === _mcPendingBatchIndices[_mcPendingBatchIndices.length - 1]);
    if (firstSent) tsStart = firstSent.startTime;
    if (lastSent) tsEnd = lastSent.endTime;
  } else if (sent && sent.words && sent.words.length > 0) {
    // Single sentence: calculate from words
    const wordTexts = sent.words.map(w => w.t);
    const fullText = wordTexts.join('');
    const pos = fullText.indexOf(_mcPendingText);
    if (pos >= 0) {
      let charCount = 0, sw = null, ew = null;
      for (let i = 0; i < wordTexts.length; i++) {
        const wEnd = charCount + wordTexts[i].length;
        if (sw === null && wEnd > pos) sw = i;
        if (wEnd >= pos + _mcPendingText.length) { ew = i; break; }
        charCount = wEnd;
      }
      if (sw !== null && ew !== null) {
        tsStart = sent.words[sw].s;
        tsEnd = sent.words[ew].e;
      }
    }
  }

  const mc = {
    id: id,
    sentenceIdx: _mcPendingSentenceIdx,
    batchIndices: _mcPendingBatchIndices || null,
    speaker: sent ? sent.speaker : '',
    selectedText: _mcPendingText,
    fullSentence: sent ? sent.text : '',
    type: mcType,
    typeLabel: mcTypeLabels[mcType] || mcType,
    reason: reason || '',
    timestamp: tsStart !== null ? { start: tsStart, end: tsEnd } : null
  };
  missedCatches.push(mc);

  // Just hide panel, deletion was already done
  document.getElementById('missed-catch-panel').classList.remove('visible');
  // Re-render to show the missed-catch tag
  rebuildRowWithManualEdits(_mcPendingSentenceIdx);
  _mcPendingText = '';
  _mcPendingSentenceIdx = -1;
  _mcPendingBatchIndices = null;
  updateStats();
}

function removeMissedCatch(id) {
  const idx = missedCatches.findIndex(mc => mc.id === id);
  if (idx >= 0) {
    const sentIdx = missedCatches[idx].sentenceIdx;
    missedCatches.splice(idx, 1);
    rebuildRowWithManualEdits(sentIdx);
    updateStats();
  }
}

// Patch rebuildRowWithManualEdits to also render missed catches + comments
// Uses DOM manipulation instead of regex on HTML to avoid attribute corruption
const _origRebuild = rebuildRowWithManualEdits;
rebuildRowWithManualEdits = function(sentenceIdx) {
  _origRebuild(sentenceIdx);
  const row = document.getElementById('row-' + sentenceIdx);
  if (!row) return;
  const textEl = row.querySelector('.s-text');
  if (!textEl) return;

  // 1) Render missed catches on manual-delete spans
  const sentMC = missedCatches.filter(mc => mc.sentenceIdx === sentenceIdx);
  for (const mc of sentMC) {
    const manualSpans = textEl.querySelectorAll('.manual-delete');
    for (const span of manualSpans) {
      if (span.textContent === mc.selectedText || span.textContent.includes(mc.selectedText)) {
        span.classList.add('missed-catch');
        span.title = mc.typeLabel + ': ' + (mc.reason || '无理由');
        const tag = document.createElement('span');
        tag.className = 'missed-catch-tag';
        tag.onclick = function(e) { e.stopPropagation(); removeMissedCatch(mc.id); };
        tag.title = '点击取消';
        tag.textContent = mc.typeLabel;
        span.parentNode.insertBefore(tag, span);
        break;
      }
    }
  }

  // 2) Render comments as blue underline highlights
  const sentComments = comments.filter(c => c.sentenceIdx === sentenceIdx);
  if (sentComments.length === 0) return;

  // Get pure text from textEl for matching
  const walker = document.createTreeWalker(textEl, NodeFilter.SHOW_TEXT, null, false);
  const textNodes = [];
  let node;
  while ((node = walker.nextNode())) textNodes.push(node);

  for (const c of sentComments) {
    // Build full text and find the comment text position
    let fullText = '';
    const nodeMap = []; // [{node, start, end}]
    textNodes.forEach(tn => {
      // Skip text inside tag badges
      if (tn.parentElement.closest('.fine-tag, .manual-tag, .silence-pause, .incoming-silence, .incoming-silence, .missed-catch-tag, .comment-tag')) return;
      const start = fullText.length;
      fullText += tn.textContent;
      nodeMap.push({ node: tn, start: start, end: fullText.length });
    });

    let pos = -1;
    if (c.charOffset !== undefined && fullText.substring(c.charOffset, c.charOffset + c.selectedText.length) === c.selectedText) {
      pos = c.charOffset;
    } else {
      pos = fullText.indexOf(c.selectedText);
    }
    if (pos < 0) continue;
    const endPos = pos + c.selectedText.length;

    // Find text nodes to wrap
    for (const nm of nodeMap) {
      if (nm.end <= pos || nm.start >= endPos) continue;
      // This text node overlaps with the comment range
      const nodeStart = Math.max(pos - nm.start, 0);
      const nodeEnd = Math.min(endPos - nm.start, nm.node.textContent.length);

      if (nodeStart === 0 && nodeEnd === nm.node.textContent.length) {
        // Wrap entire node
        const wrapper = document.createElement('span');
        wrapper.className = 'comment-highlight';
        wrapper.title = c.typeLabel + ': ' + (c.reason || '无备注') + ' (点击删除评论)';
        wrapper.onclick = function(e) { e.stopPropagation(); removeComment(c.id); };
        nm.node.parentNode.insertBefore(wrapper, nm.node);
        wrapper.appendChild(nm.node);
        // Add tag after first wrapped node
        if (nm.start <= pos) {
          const tag = document.createElement('span');
          tag.className = 'comment-tag';
          tag.textContent = c.typeLabel;
          wrapper.parentNode.insertBefore(tag, wrapper.nextSibling);
        }
      } else {
        // Split and wrap partial
        const before = nm.node.textContent.substring(0, nodeStart);
        const target = nm.node.textContent.substring(nodeStart, nodeEnd);
        const after = nm.node.textContent.substring(nodeEnd);

        const wrapper = document.createElement('span');
        wrapper.className = 'comment-highlight';
        wrapper.title = c.typeLabel + ': ' + (c.reason || '无备注') + ' (点击删除评论)';
        wrapper.onclick = function(e) { e.stopPropagation(); removeComment(c.id); };
        wrapper.textContent = target;

        const parent = nm.node.parentNode;
        if (before) parent.insertBefore(document.createTextNode(before), nm.node);
        parent.insertBefore(wrapper, nm.node);
        if (after) parent.insertBefore(document.createTextNode(after), nm.node);
        parent.removeChild(nm.node);

        // Add tag after first wrapped segment
        if (nm.start <= pos || nm.start === nodeMap[0].start) {
          const tag = document.createElement('span');
          tag.className = 'comment-tag';
          tag.textContent = c.typeLabel;
          wrapper.parentNode.insertBefore(tag, wrapper.nextSibling);
        }
      }
      break; // Only wrap first matching node (comment usually in one text node)
    }
  }
};

function exportFeedback() {
  const hasData = missedCatches.length > 0 || comments.length > 0 || restoreFeedback.length > 0
    || userAddedDeletions.size > 0 || userRemovedDeletions.size > 0;
  if (!hasData) {
    alert('暂无反馈数据。可以：\n- 选中文字标记删除（记录遗漏）\n- 选中文字添加评论\n- 恢复删除并记录理由');
    return;
  }

  // Collect user corrections (added/removed deletions)
  const addedDeletions = Array.from(userAddedDeletions).sort((a,b) => a-b);
  const removedDeletions = Array.from(userRemovedDeletions).sort((a,b) => a-b);

  const byType = {};
  missedCatches.forEach(mc => {
    byType[mc.type] = (byType[mc.type] || 0) + 1;
  });

  const feedbackData = {
    version: 'feedback_v2',
    exported_at: new Date().toISOString(),
    audio_source: document.title || '',
    missed_catches: missedCatches.map(mc => ({
      sentenceIdx: mc.sentenceIdx,
      speaker: mc.speaker,
      selectedText: mc.selectedText,
      fullSentence: mc.fullSentence,
      type: mc.type,
      typeLabel: mc.typeLabel,
      reason: mc.reason,
      timestamp: mc.timestamp
    })),
    comments: comments.map(c => ({
      sentenceIdx: c.sentenceIdx,
      selectedText: c.selectedText,
      charOffset: c.charOffset,
      type: c.type,
      typeLabel: c.typeLabel,
      reason: c.reason,
      timestamp: c.timestamp
    })),
    restore_feedback: restoreFeedback.map(rf => ({
      sentenceIdx: rf.sentenceIdx,
      restoredText: rf.restoredText,
      editType: rf.editType,
      type: rf.type,
      typeLabel: rf.typeLabel,
      reason: rf.reason
    })),
    user_corrections: {
      added_deletions: addedDeletions,
      removed_deletions: removedDeletions
    },
    summary: {
      total_missed: missedCatches.length,
      total_comments: comments.length,
      total_restores: restoreFeedback.length,
      by_type: byType
    }
  };

  const blob = new Blob([JSON.stringify(feedbackData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ai_feedback_' + new Date().toISOString().slice(0,10) + '.json';
  a.click();
  URL.revokeObjectURL(url);

  const toast = document.createElement('div');
  toast.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1e3a5f;color:#e0e0e0;padding:24px;border-radius:12px;z-index:9999;max-width:500px;box-shadow:0 8px 32px rgba(0,0,0,0.5);font-size:14px;';
  let typesSummary = Object.entries(byType).map(([t, c]) => `${mcTypeLabels[t] || t}: ${c}`).join('、');
  const parts = [];
  if (missedCatches.length > 0) parts.push(missedCatches.length + ' 个遗漏标记' + (typesSummary ? '（' + typesSummary + '）' : ''));
  if (comments.length > 0) parts.push(comments.length + ' 条评论');
  if (restoreFeedback.length > 0) parts.push(restoreFeedback.length + ' 条恢复理由');
  toast.innerHTML = `
    <div style="margin-bottom:12px;font-size:16px;font-weight:bold;">&#128270; 已导出 AI 反馈文件</div>
    <div style="margin-bottom:8px;">${parts.join('、') || '用户修正记录'}</div>
    <div style="margin-bottom:8px;">将文件交给 AI，运行自进化 skill 更新规则：</div>
    <div style="background:#0d1117;padding:10px;border-radius:8px;font-family:monospace;font-size:13px;">/podcastcut:自进化</div>
    <button onclick="this.parentElement.remove()" style="margin-top:12px;padding:6px 16px;background:#333;color:#fff;border:none;border-radius:6px;cursor:pointer;">关闭</button>
  `;
  document.body.appendChild(toast);
}

// Close missed catch panel on outside click
document.addEventListener('mousedown', function(e) {
  if (!e.target.closest('#missed-catch-panel') && document.getElementById('missed-catch-panel').classList.contains('visible')) {
    hideMissedCatchPanel();
  }
});

// Warn before closing if there are unsaved changes (belt-and-suspenders with auto-save)
window.addEventListener('beforeunload', function(e) {
  if (_hasUnsavedEdits) {
    _doSave(); // Force save before unload
  }
});

// ===== IMPROVEMENT 1: Delete/Backspace key to delete selected text =====
document.addEventListener('keydown', function(e) {
  if (e.key !== 'Delete' && e.key !== 'Backspace') return;
  // Don't interfere with input/textarea/select elements
  const tag = e.target.tagName.toLowerCase();
  if (tag === 'input' || tag === 'textarea' || tag === 'select' || e.target.isContentEditable) return;

  const sel = window.getSelection();
  if (!sel || sel.isCollapsed || sel.toString().trim().length === 0) return;

  // If multi-row selection exists, batch delete those rows
  const selectedRows = getSelectedRowIndices();
  if (selectedRows.length >= 2) {
    e.preventDefault();
    _selectionRowIndices = selectedRows;
    selectionBatchDelete();
    return;
  }

  // Check if selection is within a sentence text element (word-level edit)
  const anchor = sel.anchorNode;
  if (!anchor) return;
  const textEl = anchor.parentElement.closest('.s-text');
  if (!textEl) return;

  e.preventDefault();
  markSelectionDeletedAndPrompt();
});

// ===== IMPROVEMENT 2: Speaker panel + click to rename =====
function buildSpeakerPanel() {
  const panel = document.getElementById('speaker-panel');
  if (!panel) return;
  // Keep the label, clear the rest
  while (panel.children.length > 1) panel.removeChild(panel.lastChild);

  const speakers = getAllSpeakers();
  speakers.forEach((sp, i) => {
    const count = sentencesData.filter(x => x.speaker === sp).length;
    const chip = document.createElement('button');
    chip.className = 'filter-btn';
    chip.style.cssText = 'display:inline-flex;align-items:center;gap:4px;cursor:pointer;';
    chip.innerHTML = sp + ' <span style="opacity:0.5;font-size:11px;">' + count + '句 &#9998;</span>';
    chip.title = '点击修改「' + sp + '」的名字';
    chip.addEventListener('click', function(e) {
      e.stopPropagation();
      promptRenameSpeaker(sp);
    });
    panel.appendChild(chip);
  });
}

function promptRenameSpeaker(oldName) {
  closeSpeakerDropdown();
  const newName = prompt('将「' + oldName + '」改为：');
  if (!newName || !newName.trim() || newName.trim() === oldName) return;
  // Use a fake sentenceIdx — applySpeakerChange does bulk replace by oldName
  const first = sentencesData.find(s => s.speaker === oldName);
  if (first) applySpeakerChange(first.idx, newName.trim());
  buildSpeakerPanel(); // refresh panel
}

function getAllSpeakers() {
  const speakers = new Set();
  sentencesData.forEach(s => {
    speakers.add(speakerModifications[s.idx] !== undefined ? speakerModifications[s.idx] : s.speaker);
  });
  return Array.from(speakers).filter(Boolean);
}

function showSpeakerDropdown(speakerEl, sentenceIdx) {
  // Remove any existing dropdown
  closeSpeakerDropdown();

  const speakers = getAllSpeakers();
  const currentSpeaker = speakerModifications[sentenceIdx] !== undefined
    ? speakerModifications[sentenceIdx]
    : sentencesData.find(s => s.idx === sentenceIdx).speaker;

  const dropdown = document.createElement('div');
  dropdown.className = 'speaker-edit-dropdown';
  dropdown.id = 'speaker-dropdown';

  // Add known speakers as options
  speakers.forEach(sp => {
    const opt = document.createElement('div');
    opt.textContent = sp;
    if (sp === currentSpeaker) opt.style.fontWeight = 'bold';
    opt.addEventListener('click', function(e) {
      e.stopPropagation();
      applySpeakerChange(sentenceIdx, sp);
      closeSpeakerDropdown();
    });
    dropdown.appendChild(opt);
  });

  // Add custom input
  const input = document.createElement('input');
  input.type = 'text';
  input.placeholder = '输入新名字...';
  input.addEventListener('keydown', function(e) {
    e.stopPropagation();
    if (e.key === 'Enter' && this.value.trim()) {
      applySpeakerChange(sentenceIdx, this.value.trim());
      closeSpeakerDropdown();
    } else if (e.key === 'Escape') {
      closeSpeakerDropdown();
    }
  });
  input.addEventListener('click', function(e) { e.stopPropagation(); });
  dropdown.appendChild(input);

  // Position dropdown below the speaker element
  const rect = speakerEl.getBoundingClientRect();
  dropdown.style.position = 'fixed';
  dropdown.style.left = rect.left + 'px';
  dropdown.style.top = (rect.bottom + 2) + 'px';

  document.body.appendChild(dropdown);
  setTimeout(() => input.focus(), 50);
}

function closeSpeakerDropdown() {
  const existing = document.getElementById('speaker-dropdown');
  if (existing) existing.remove();
}

function refreshSpeakerLabels() {
  sentencesData.forEach(s => {
    const row = document.getElementById('row-' + s.idx);
    if (!row) return;
    const spEl = row.querySelector('.s-speaker');
    if (!spEl) return;
    spEl.textContent = s.speaker;
    const spClass = __SPEAKER_CLASS_FUNC__;
    spEl.className = 's-speaker ' + spClass;
  });
}

function applySpeakerChange(sentenceIdx, newSpeaker) {
  const clicked = sentencesData.find(x => x.idx === sentenceIdx);
  if (!clicked) return;
  const oldSpeaker = clicked.speaker;
  if (oldSpeaker === newSpeaker) return;

  // Bulk replace: change ALL sentences with the same old speaker name
  let count = 0;
  sentencesData.forEach(s => {
    if (s.speaker === oldSpeaker) {
      s.speaker = newSpeaker;
      speakerModifications[s.idx] = newSpeaker;
      count++;
    }
  });
  refreshSpeakerLabels();
  _showSaveIndicator('✓ 已将 ' + oldSpeaker + ' → ' + newSpeaker + '（' + count + ' 句）');
  autoSave();
  buildSpeakerPanel();
}

// Delegate click on speaker elements
document.addEventListener('click', function(e) {
  const spEl = e.target.closest('.s-speaker');
  if (spEl) {
    e.stopPropagation();
    const row = spEl.closest('[id^="row-"]');
    if (!row) return;
    const sentenceIdx = parseInt(row.id.replace('row-', ''));
    showSpeakerDropdown(spEl, sentenceIdx);
    return;
  }
  // Close dropdown if clicking outside
  if (!e.target.closest('.speaker-edit-dropdown')) {
    closeSpeakerDropdown();
  }
});

// ===== COMMENT SYSTEM =====
// (comments, commentCounter declared earlier with other data arrays)
const commentTypeLabels = {
  audio_glitch: '卡顿/爆破感',
  awkward_cut: '切割不自然',
  keep_but_note: '保留但备注',
  quality_issue: '音质问题',
  other: '其他'
};

let _commentPendingText = '';
let _commentPendingSentenceIdx = -1;
let _commentPendingCharOffset = undefined;

function addCommentToSelection() {
  const sel = window.getSelection();
  if (!sel || sel.isCollapsed) return;

  const range = sel.getRangeAt(0);
  const fragment = range.cloneContents();
  fragment.querySelectorAll('.fine-tag, .manual-tag, .silence-pause, .incoming-silence, .incoming-silence, .missed-catch-tag, .comment-tag').forEach(el => el.remove());
  const selectedText = (fragment.textContent || '').trim();
  if (!selectedText) return;

  const anchor = sel.anchorNode;
  const textEl = anchor.parentElement.closest('.s-text');
  if (!textEl) return;
  const row = textEl.closest('[id^="row-"]');
  if (!row) return;
  const sentenceIdx = parseInt(row.id.replace('row-', ''));

  // Calculate charOffset
  let charOffset;
  try {
    const preRange = document.createRange();
    preRange.setStart(textEl, 0);
    preRange.setEnd(range.startContainer, range.startOffset);
    const preFrag = preRange.cloneContents();
    preFrag.querySelectorAll('.fine-tag, .manual-tag, .silence-pause, .incoming-silence, .incoming-silence, .missed-catch-tag, .comment-tag').forEach(el => el.remove());
    charOffset = (preFrag.textContent || '').length;
  } catch(e) { charOffset = undefined; }

  _commentPendingText = selectedText;
  _commentPendingSentenceIdx = sentenceIdx;
  _commentPendingCharOffset = charOffset;

  sel.removeAllRanges();
  document.getElementById('selection-toolbar').classList.remove('visible');

  // Show comment panel
  const panel = document.getElementById('comment-panel');
  document.getElementById('comment-preview-text').textContent = selectedText.length > 80 ? selectedText.slice(0, 80) + '...' : selectedText;
  document.getElementById('comment-reason').value = '';
  const rowRect = row.getBoundingClientRect();
  panel.style.left = Math.min(rowRect.left + 40, window.innerWidth - 340) + 'px';
  panel.style.top = (rowRect.bottom + 4) + 'px';
  panel.classList.add('visible');
  setTimeout(() => document.getElementById('comment-type').focus(), 100);
}

function hideCommentPanel() {
  document.getElementById('comment-panel').classList.remove('visible');
  _commentPendingText = '';
  _commentPendingSentenceIdx = -1;
  _commentPendingCharOffset = undefined;
}

function confirmComment() {
  if (!_commentPendingText || _commentPendingSentenceIdx < 0) return;

  const cType = document.getElementById('comment-type').value;
  const reason = document.getElementById('comment-reason').value.trim();
  const id = ++commentCounter;

  const sent = sentencesData.find(s => s.idx === _commentPendingSentenceIdx);

  // Calculate timestamp
  let tsStart = null, tsEnd = null;
  if (sent && sent.words && sent.words.length > 0) {
    const wordTexts = sent.words.map(w => w.t);
    const fullText = wordTexts.join('');
    const pos = _commentPendingCharOffset !== undefined ? _commentPendingCharOffset : fullText.indexOf(_commentPendingText);
    if (pos >= 0) {
      let charCount = 0, sw = null, ew = null;
      for (let i = 0; i < wordTexts.length; i++) {
        const wEnd = charCount + wordTexts[i].length;
        if (sw === null && wEnd > pos) sw = i;
        if (wEnd >= pos + _commentPendingText.length) { ew = i; break; }
        charCount = wEnd;
      }
      if (sw !== null && ew !== null) {
        tsStart = sent.words[sw].s;
        tsEnd = sent.words[ew].e;
      }
    }
  }

  const comment = {
    id: id,
    sentenceIdx: _commentPendingSentenceIdx,
    selectedText: _commentPendingText,
    charOffset: _commentPendingCharOffset,
    type: cType,
    typeLabel: commentTypeLabels[cType] || cType,
    reason: reason || '',
    timestamp: tsStart !== null ? { start: tsStart, end: tsEnd } : null
  };
  comments.push(comment);

  document.getElementById('comment-panel').classList.remove('visible');
  rebuildRowWithManualEdits(_commentPendingSentenceIdx);
  _commentPendingText = '';
  _commentPendingSentenceIdx = -1;
  _commentPendingCharOffset = undefined;
  autoSave();
  _showSaveIndicator('✓ 已添加评论');
}

function removeComment(id) {
  const idx = comments.findIndex(c => c.id === id);
  if (idx >= 0) {
    const sentIdx = comments[idx].sentenceIdx;
    comments.splice(idx, 1);
    rebuildRowWithManualEdits(sentIdx);
    autoSave();
  }
}

// ===== RESTORE FEEDBACK =====
// (restoreFeedback, restoreFeedbackCounter declared earlier with other data arrays)
const restoreTypeLabels = {
  important_content: '重要内容',
  context_needed: '上下文需要',
  natural_flow: '保持自然',
  ai_misjudge: 'AI 误判',
  other: '其他'
};

let _restorePending = null; // { type: 'sentence'|'fine'|'manual', idx/editId, text, sentenceIdx, callback }

function showRestorePanel(info) {
  _restorePending = info;
  const panel = document.getElementById('restore-panel');
  document.getElementById('restore-preview-text').textContent = (info.text || '').length > 80 ? info.text.slice(0, 80) + '...' : (info.text || '');
  document.getElementById('restore-reason').value = '';
  document.getElementById('restore-type').value = 'important_content';

  // Position near the row
  const row = document.getElementById('row-' + info.sentenceIdx);
  if (row) {
    const rect = row.getBoundingClientRect();
    panel.style.left = Math.min(rect.left + 40, window.innerWidth - 340) + 'px';
    panel.style.top = (rect.bottom + 4) + 'px';
  } else {
    panel.style.left = '40%';
    panel.style.top = '40%';
  }
  panel.classList.add('visible');
  setTimeout(() => document.getElementById('restore-type').focus(), 100);
}

function hideRestorePanel() {
  document.getElementById('restore-panel').classList.remove('visible');
  _restorePending = null;
}

function confirmRestore() {
  if (!_restorePending) return;
  const rType = document.getElementById('restore-type').value;
  const reason = document.getElementById('restore-reason').value.trim();
  const id = ++restoreFeedbackCounter;

  restoreFeedback.push({
    id: id,
    sentenceIdx: _restorePending.sentenceIdx,
    type: rType,
    typeLabel: restoreTypeLabels[rType] || rType,
    reason: reason || '',
    restoredText: _restorePending.text || '',
    editType: _restorePending.editType
  });

  document.getElementById('restore-panel').classList.remove('visible');
  _restorePending = null;
  autoSave();
}

// Panel keyboard handlers (comment + restore)
document.addEventListener('keydown', function(e) {
  if (e.key === 'Enter') {
    if (document.getElementById('comment-panel').classList.contains('visible')) {
      e.preventDefault(); confirmComment();
    } else if (document.getElementById('restore-panel').classList.contains('visible')) {
      e.preventDefault(); confirmRestore();
    }
  }
  if (e.key === 'Escape') {
    if (document.getElementById('comment-panel').classList.contains('visible')) {
      e.preventDefault(); hideCommentPanel();
    } else if (document.getElementById('restore-panel').classList.contains('visible')) {
      e.preventDefault(); hideRestorePanel();
    }
  }
});

// Close panels on outside click
document.addEventListener('mousedown', function(e) {
  if (!e.target.closest('#comment-panel') && document.getElementById('comment-panel').classList.contains('visible')) {
    hideCommentPanel();
  }
  if (!e.target.closest('#restore-panel') && document.getElementById('restore-panel').classList.contains('visible')) {
    hideRestorePanel();
  }
});


</script>

<div id="selection-toolbar">
  <span class="sel-text" id="sel-preview"></span>
  <button onclick="markSelectionDeletedAndPrompt()">&#9986; 删除</button>
  <button class="comment-btn" onclick="addCommentToSelection()">&#128172; 评论</button>
</div>

<div id="missed-catch-panel">
  <div class="mc-title">&#128161; AI没识别到这个，帮忙记录一下？</div>
  <div class="mc-preview" id="mc-preview-text"></div>
  <select id="mc-type">
    <option value="in_sentence_repeat">句内重复</option>
    <option value="repeated_sentence">重复句</option>
    <option value="stutter">卡顿词</option>
    <option value="self_correction">重说纠正</option>
    <option value="consecutive_filler">连续填充词</option>
    <option value="residual_sentence">残句</option>
    <option value="silence">长静音</option>
    <option value="production_talk">录制讨论/协调</option>
    <option value="chit_chat">闲聊</option>
    <option value="other">其他</option>
  </select>
  <input type="text" id="mc-reason" placeholder="简述理由（选填，回车确认）">
  <div class="mc-btns">
    <button class="mc-btn mc-btn-cancel" onclick="hideMissedCatchPanel()">跳过</button>
    <button class="mc-btn mc-btn-ok" onclick="confirmMissedCatch()">记录</button>
  </div>
</div>

<div id="comment-panel" class="feedback-panel">
  <div class="mc-title">&#128172; 添加评论</div>
  <div class="mc-preview" id="comment-preview-text"></div>
  <select id="comment-type">
    <option value="audio_glitch">卡顿/爆破感</option>
    <option value="awkward_cut">切割不自然</option>
    <option value="keep_but_note">保留但备注</option>
    <option value="quality_issue">音质问题</option>
    <option value="other">其他</option>
  </select>
  <input type="text" id="comment-reason" placeholder="描述问题（选填，回车确认）">
  <div class="mc-btns">
    <button class="mc-btn mc-btn-cancel" onclick="hideCommentPanel()">取消</button>
    <button class="mc-btn mc-btn-ok" onclick="confirmComment()">添加</button>
  </div>
</div>

<div id="restore-panel" class="feedback-panel">
  <div class="mc-title">&#128161; 为什么恢复这段？</div>
  <div class="mc-preview" id="restore-preview-text"></div>
  <select id="restore-type">
    <option value="important_content">重要内容，不应删</option>
    <option value="context_needed">上下文需要</option>
    <option value="natural_flow">保持对话自然</option>
    <option value="ai_misjudge">AI 误判</option>
    <option value="other">其他</option>
  </select>
  <input type="text" id="restore-reason" placeholder="简述理由（选填，回车确认）">
  <div class="mc-btns">
    <button class="mc-btn mc-btn-cancel" onclick="hideRestorePanel()">跳过</button>
    <button class="mc-btn mc-btn-ok" onclick="confirmRestore()">记录</button>
  </div>
</div>

</body>
</html>
